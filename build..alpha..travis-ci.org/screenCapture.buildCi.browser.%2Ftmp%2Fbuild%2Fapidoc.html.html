<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://cujojs.com">when (v3.7.8)</a>
</h1>
<h4>A lightweight Promises/A+ and when() implementation, plus other async goodies.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.when">module when</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.when">
            function <span class="apidocSignatureSpan"></span>when
            <span class="apidocSignatureSpan">(x, onFulfilled, onRejected, onProgress)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.ConsoleReporter">
            function <span class="apidocSignatureSpan">when.</span>ConsoleReporter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise">
            function <span class="apidocSignatureSpan">when.</span>Promise
            <span class="apidocSignatureSpan">(resolver, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.PromiseMonitor">
            function <span class="apidocSignatureSpan">when.</span>PromiseMonitor
            <span class="apidocSignatureSpan">(reporter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Scheduler">
            function <span class="apidocSignatureSpan">when.</span>Scheduler
            <span class="apidocSignatureSpan">(async)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.TimeoutError">
            function <span class="apidocSignatureSpan">when.</span>TimeoutError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.all">
            function <span class="apidocSignatureSpan">when.</span>all
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.any">
            function <span class="apidocSignatureSpan">when.</span>any
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.apply">
            function <span class="apidocSignatureSpan">when.</span>apply
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.attempt">
            function <span class="apidocSignatureSpan">when.</span>attempt
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.defer">
            function <span class="apidocSignatureSpan">when.</span>defer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.filter">
            function <span class="apidocSignatureSpan">when.</span>filter
            <span class="apidocSignatureSpan">(promises, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.guard">
            function <span class="apidocSignatureSpan">when.</span>guard
            <span class="apidocSignatureSpan">(condition, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.isPromiseLike">
            function <span class="apidocSignatureSpan">when.</span>isPromiseLike
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.iterate">
            function <span class="apidocSignatureSpan">when.</span>iterate
            <span class="apidocSignatureSpan">(f, condition, handler, x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.join">
            function <span class="apidocSignatureSpan">when.</span>join
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.lift">
            function <span class="apidocSignatureSpan">when.</span>lift
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.map">
            function <span class="apidocSignatureSpan">when.</span>map
            <span class="apidocSignatureSpan">(promises, mapFunc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.promise">
            function <span class="apidocSignatureSpan">when.</span>promise
            <span class="apidocSignatureSpan">(resolver)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.race">
            function <span class="apidocSignatureSpan">when.</span>race
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.reduce">
            function <span class="apidocSignatureSpan">when.</span>reduce
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.reduceRight">
            function <span class="apidocSignatureSpan">when.</span>reduceRight
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.reject">
            function <span class="apidocSignatureSpan">when.</span>reject
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.resolve">
            function <span class="apidocSignatureSpan">when.</span>resolve
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.settle">
            function <span class="apidocSignatureSpan">when.</span>settle
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.some">
            function <span class="apidocSignatureSpan">when.</span>some
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.try">
            function <span class="apidocSignatureSpan">when.</span>try
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.unfold">
            function <span class="apidocSignatureSpan">when.</span>unfold
            <span class="apidocSignatureSpan">(unspool, condition, handler, x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.</span>ConsoleReporter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.</span>Promise.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.</span>PromiseMonitor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.</span>Scheduler.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.</span>TimeoutError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.</span>callbacks</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.</span>console</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.</span>env</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.</span>error</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.</span>format</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.</span>function</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.</span>generator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.</span>keys</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.</span>node</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.</span>state</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.ConsoleReporter">module when.ConsoleReporter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.ConsoleReporter.ConsoleReporter">
            function <span class="apidocSignatureSpan">when.</span>ConsoleReporter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.ConsoleReporter.prototype">module when.ConsoleReporter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.ConsoleReporter.prototype._log">
            function <span class="apidocSignatureSpan">when.ConsoleReporter.prototype.</span>_log
            <span class="apidocSignatureSpan">(traces)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.ConsoleReporter.prototype.groupEnd">
            function <span class="apidocSignatureSpan">when.ConsoleReporter.prototype.</span>groupEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.ConsoleReporter.prototype.groupStart">
            function <span class="apidocSignatureSpan">when.ConsoleReporter.prototype.</span>groupStart
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.ConsoleReporter.prototype.log">
            function <span class="apidocSignatureSpan">when.ConsoleReporter.prototype.</span>log
            <span class="apidocSignatureSpan">(traces)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.ConsoleReporter.prototype.msg">
            function <span class="apidocSignatureSpan">when.ConsoleReporter.prototype.</span>msg
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.ConsoleReporter.prototype.warn">
            function <span class="apidocSignatureSpan">when.ConsoleReporter.prototype.</span>warn
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.Promise">module when.Promise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.Promise">
            function <span class="apidocSignatureSpan">when.</span>Promise
            <span class="apidocSignatureSpan">(resolver, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise._defer">
            function <span class="apidocSignatureSpan">when.Promise.</span>_defer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise._handler">
            function <span class="apidocSignatureSpan">when.Promise.</span>_handler
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise._traverse">
            function <span class="apidocSignatureSpan">when.Promise.</span>_traverse
            <span class="apidocSignatureSpan">(f, promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise._visitRemaining">
            function <span class="apidocSignatureSpan">when.Promise.</span>_visitRemaining
            <span class="apidocSignatureSpan">(promises, start, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.all">
            function <span class="apidocSignatureSpan">when.Promise.</span>all
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.any">
            function <span class="apidocSignatureSpan">when.Promise.</span>any
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.createContext">
            function <span class="apidocSignatureSpan">when.Promise.</span>createContext
            <span class="apidocSignatureSpan">(p, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.enterContext">
            function <span class="apidocSignatureSpan">when.Promise.</span>enterContext
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.exitContext">
            function <span class="apidocSignatureSpan">when.Promise.</span>exitContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.filter">
            function <span class="apidocSignatureSpan">when.Promise.</span>filter
            <span class="apidocSignatureSpan">(promises, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.iterate">
            function <span class="apidocSignatureSpan">when.Promise.</span>iterate
            <span class="apidocSignatureSpan">(f, condition, handler, x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.map">
            function <span class="apidocSignatureSpan">when.Promise.</span>map
            <span class="apidocSignatureSpan">(promises, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.never">
            function <span class="apidocSignatureSpan">when.Promise.</span>never
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.onFatalRejection">
            function <span class="apidocSignatureSpan">when.Promise.</span>onFatalRejection
            <span class="apidocSignatureSpan">(rejection, extraContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.onPotentiallyUnhandledRejection">
            function <span class="apidocSignatureSpan">when.Promise.</span>onPotentiallyUnhandledRejection
            <span class="apidocSignatureSpan">(rejection, extraContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.onPotentiallyUnhandledRejectionHandled">
            function <span class="apidocSignatureSpan">when.Promise.</span>onPotentiallyUnhandledRejectionHandled
            <span class="apidocSignatureSpan">(rejection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.race">
            function <span class="apidocSignatureSpan">when.Promise.</span>race
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.reduce">
            function <span class="apidocSignatureSpan">when.Promise.</span>reduce
            <span class="apidocSignatureSpan">(promises, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.reduceRight">
            function <span class="apidocSignatureSpan">when.Promise.</span>reduceRight
            <span class="apidocSignatureSpan">(promises, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.reject">
            function <span class="apidocSignatureSpan">when.Promise.</span>reject
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.resolve">
            function <span class="apidocSignatureSpan">when.Promise.</span>resolve
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.settle">
            function <span class="apidocSignatureSpan">when.Promise.</span>settle
            <span class="apidocSignatureSpan">(promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.some">
            function <span class="apidocSignatureSpan">when.Promise.</span>some
            <span class="apidocSignatureSpan">(promises, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.unfold">
            function <span class="apidocSignatureSpan">when.Promise.</span>unfold
            <span class="apidocSignatureSpan">(unspool, condition, handler, x)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.Promise.prototype">module when.Promise.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype._beget">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>_beget
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.catch">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>catch
            <span class="apidocSignatureSpan">(onRejected)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.delay">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>delay
            <span class="apidocSignatureSpan">(ms)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.done">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>done
            <span class="apidocSignatureSpan">(onResult, onError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.else">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>else
            <span class="apidocSignatureSpan">(defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.ensure">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>ensure
            <span class="apidocSignatureSpan">(handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.finally">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>finally
            <span class="apidocSignatureSpan">(handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.fold">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>fold
            <span class="apidocSignatureSpan">(f, z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.inspect">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.orElse">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>orElse
            <span class="apidocSignatureSpan">(defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.otherwise">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>otherwise
            <span class="apidocSignatureSpan">(onRejected)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.progress">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>progress
            <span class="apidocSignatureSpan">(onProgress)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.spread">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>spread
            <span class="apidocSignatureSpan">(onFulfilled)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.tap">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>tap
            <span class="apidocSignatureSpan">(onFulfilledSideEffect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.then">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>then
            <span class="apidocSignatureSpan">(onFulfilled, onRejected, onProgress)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.timeout">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>timeout
            <span class="apidocSignatureSpan">(ms, reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.with">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>with
            <span class="apidocSignatureSpan">(receiver)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.withThis">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>withThis
            <span class="apidocSignatureSpan">(receiver)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Promise.prototype.yield">
            function <span class="apidocSignatureSpan">when.Promise.prototype.</span>yield
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.PromiseMonitor">module when.PromiseMonitor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.PromiseMonitor.PromiseMonitor">
            function <span class="apidocSignatureSpan">when.</span>PromiseMonitor
            <span class="apidocSignatureSpan">(reporter)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.PromiseMonitor.prototype">module when.PromiseMonitor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.PromiseMonitor.prototype._appendContext">
            function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>_appendContext
            <span class="apidocSignatureSpan">(trace, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.PromiseMonitor.prototype._createLongTrace">
            function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>_createLongTrace
            <span class="apidocSignatureSpan">(e, context, extraContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.PromiseMonitor.prototype._createTrace">
            function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>_createTrace
            <span class="apidocSignatureSpan">(traceChain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.PromiseMonitor.prototype._logTraces">
            function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>_logTraces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.PromiseMonitor.prototype._removeDuplicates">
            function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>_removeDuplicates
            <span class="apidocSignatureSpan">(trace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.PromiseMonitor.prototype.addTrace">
            function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>addTrace
            <span class="apidocSignatureSpan">(handler, extraContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.PromiseMonitor.prototype.createContext">
            function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>createContext
            <span class="apidocSignatureSpan">(at, parentContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.PromiseMonitor.prototype.fatal">
            function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>fatal
            <span class="apidocSignatureSpan">(handler, extraContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.PromiseMonitor.prototype.formatTraces">
            function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>formatTraces
            <span class="apidocSignatureSpan">(traces)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.PromiseMonitor.prototype.logTraces">
            function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>logTraces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.PromiseMonitor.prototype.monitor">
            function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>monitor
            <span class="apidocSignatureSpan">(Promise)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.PromiseMonitor.prototype.removeTrace">
            function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>removeTrace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.Scheduler">module when.Scheduler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Scheduler.Scheduler">
            function <span class="apidocSignatureSpan">when.</span>Scheduler
            <span class="apidocSignatureSpan">(async)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.Scheduler.prototype">module when.Scheduler.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Scheduler.prototype._drain">
            function <span class="apidocSignatureSpan">when.Scheduler.prototype.</span>_drain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Scheduler.prototype.afterQueue">
            function <span class="apidocSignatureSpan">when.Scheduler.prototype.</span>afterQueue
            <span class="apidocSignatureSpan">(task)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Scheduler.prototype.enqueue">
            function <span class="apidocSignatureSpan">when.Scheduler.prototype.</span>enqueue
            <span class="apidocSignatureSpan">(task)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.Scheduler.prototype.run">
            function <span class="apidocSignatureSpan">when.Scheduler.prototype.</span>run
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.TimeoutError">module when.TimeoutError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.TimeoutError.TimeoutError">
            function <span class="apidocSignatureSpan">when.</span>TimeoutError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.TimeoutError.prototype">module when.TimeoutError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.TimeoutError.prototype.constructor">
            function <span class="apidocSignatureSpan">when.TimeoutError.prototype.</span>constructor
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.apply">module when.apply</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.apply.apply">
            function <span class="apidocSignatureSpan">when.</span>apply
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.apply.tryCatchResolve">
            function <span class="apidocSignatureSpan">when.apply.</span>tryCatchResolve
            <span class="apidocSignatureSpan">(f, thisArg, args, resolver)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.callbacks">module when.callbacks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.callbacks.apply">
            function <span class="apidocSignatureSpan">when.callbacks.</span>apply
            <span class="apidocSignatureSpan">(asyncFunction, extraAsyncArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.callbacks.call">
            function <span class="apidocSignatureSpan">when.callbacks.</span>call
            <span class="apidocSignatureSpan">(asyncFunction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.callbacks.lift">
            function <span class="apidocSignatureSpan">when.callbacks.</span>lift
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.callbacks.liftAll">
            function <span class="apidocSignatureSpan">when.callbacks.</span>liftAll
            <span class="apidocSignatureSpan">(src, combine, dst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.callbacks.promisify">
            function <span class="apidocSignatureSpan">when.callbacks.</span>promisify
            <span class="apidocSignatureSpan">(asyncFunction, positions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.console">module when.console</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">when.console.</span>filterDuplicateFrames</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.console._doLogTraces">
            function <span class="apidocSignatureSpan">when.console.</span>_doLogTraces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">when.console.</span>_traceTask</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">when.console.</span>logDelay</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.console.</span>_reporter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.console.</span>_traces</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">when.console.</span>stackFilter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">when.console.</span>stackJumpSeparator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.env">module when.env</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.env.asap">
            function <span class="apidocSignatureSpan">when.env.</span>asap
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.env.clearTimer">
            function <span class="apidocSignatureSpan">when.env.</span>clearTimer
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.env.setTimer">
            function <span class="apidocSignatureSpan">when.env.</span>setTimer
            <span class="apidocSignatureSpan">(f, ms)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.error">module when.error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.error.captureStack">
            function <span class="apidocSignatureSpan">when.error.</span>captureStack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.error.format">
            function <span class="apidocSignatureSpan">when.error.</span>format
            <span class="apidocSignatureSpan">(longTrace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.error.parse">
            function <span class="apidocSignatureSpan">when.error.</span>parse
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.format">module when.format</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.format.formatError">
            function <span class="apidocSignatureSpan">when.format.</span>formatError
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.format.formatObject">
            function <span class="apidocSignatureSpan">when.format.</span>formatObject
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.format.tryStringify">
            function <span class="apidocSignatureSpan">when.format.</span>tryStringify
            <span class="apidocSignatureSpan">(x, defaultValue)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.function">module when.function</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.function.apply">
            function <span class="apidocSignatureSpan">when.function.</span>apply
            <span class="apidocSignatureSpan">(f, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.function.call">
            function <span class="apidocSignatureSpan">when.function.</span>call
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.function.compose">
            function <span class="apidocSignatureSpan">when.function.</span>compose
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.function.lift">
            function <span class="apidocSignatureSpan">when.function.</span>lift
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.function.liftAll">
            function <span class="apidocSignatureSpan">when.function.</span>liftAll
            <span class="apidocSignatureSpan">(src, combine, dst)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.generator">module when.generator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.generator.apply">
            function <span class="apidocSignatureSpan">when.generator.</span>apply
            <span class="apidocSignatureSpan">(generator, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.generator.call">
            function <span class="apidocSignatureSpan">when.generator.</span>call
            <span class="apidocSignatureSpan">(generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.generator.lift">
            function <span class="apidocSignatureSpan">when.generator.</span>lift
            <span class="apidocSignatureSpan">(generator)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.guard">module when.guard</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.guard.guard">
            function <span class="apidocSignatureSpan">when.</span>guard
            <span class="apidocSignatureSpan">(condition, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.guard.n">
            function <span class="apidocSignatureSpan">when.guard.</span>n
            <span class="apidocSignatureSpan">(allowed)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.keys">module when.keys</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.keys.all">
            function <span class="apidocSignatureSpan">when.keys.</span>all
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.keys.map">
            function <span class="apidocSignatureSpan">when.keys.</span>map
            <span class="apidocSignatureSpan">(object, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.keys.settle">
            function <span class="apidocSignatureSpan">when.keys.</span>settle
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.node">module when.node</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.node.apply">
            function <span class="apidocSignatureSpan">when.node.</span>apply
            <span class="apidocSignatureSpan">(f, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.node.bindCallback">
            function <span class="apidocSignatureSpan">when.node.</span>bindCallback
            <span class="apidocSignatureSpan">(promise, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.node.call">
            function <span class="apidocSignatureSpan">when.node.</span>call
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.node.createCallback">
            function <span class="apidocSignatureSpan">when.node.</span>createCallback
            <span class="apidocSignatureSpan">(resolver)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.node.lift">
            function <span class="apidocSignatureSpan">when.node.</span>lift
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.node.liftAll">
            function <span class="apidocSignatureSpan">when.node.</span>liftAll
            <span class="apidocSignatureSpan">(src, combine, dst)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.node.liftCallback">
            function <span class="apidocSignatureSpan">when.node.</span>liftCallback
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.when.state">module when.state</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.state.fulfilled">
            function <span class="apidocSignatureSpan">when.state.</span>fulfilled
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.state.inspect">
            function <span class="apidocSignatureSpan">when.state.</span>inspect
            <span class="apidocSignatureSpan">(handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.state.pending">
            function <span class="apidocSignatureSpan">when.state.</span>pending
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.when.state.rejected">
            function <span class="apidocSignatureSpan">when.state.</span>rejected
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when" id="apidoc.module.when">module when</a></h1>


    <h2>
        <a href="#apidoc.element.when.when" id="apidoc.element.when.when">
        function <span class="apidocSignatureSpan"></span>when
        <span class="apidocSignatureSpan">(x, onFulfilled, onRejected, onProgress)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function when(x, onFulfilled, onRejected, onProgress) {
		var p = Promise.resolve(x);
		if (arguments.length &lt; 2) {
			return p;
		}

		return p.then(onFulfilled, onRejected, onProgress);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			while(h.handler !== void 0) {
				h = h.handler;
			}
			return h;
		};

		Handler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {
			this.<span class="apidocCodeKeywordSpan">when</span>({
				resolver: to,
				receiver: receiver,
				fulfilled: fulfilled,
				rejected: rejected,
				progress: progress
			});
		};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.ConsoleReporter" id="apidoc.element.when.ConsoleReporter">
        function <span class="apidocSignatureSpan">when.</span>ConsoleReporter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsoleReporter() {
		this._previouslyReported = false;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise" id="apidoc.element.when.Promise">
        function <span class="apidocSignatureSpan">when.</span>Promise
        <span class="apidocSignatureSpan">(resolver, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.PromiseMonitor" id="apidoc.element.when.PromiseMonitor">
        function <span class="apidocSignatureSpan">when.</span>PromiseMonitor
        <span class="apidocSignatureSpan">(reporter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PromiseMonitor(reporter) {
		this.logDelay = 0;
		this.stackFilter = defaultStackFilter;
		this.stackJumpSeparator = defaultStackJumpSeparator;
		this.filterDuplicateFrames = true;

		this._reporter = reporter;
		if(typeof reporter.configurePromiseMonitor === 'function') {
			reporter.configurePromiseMonitor(this);
		}

		this._traces = [];
		this._traceTask = 0;

		var self = this;
		this._doLogTraces = function() {
			self._logTraces();
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Scheduler" id="apidoc.element.when.Scheduler">
        function <span class="apidocSignatureSpan">when.</span>Scheduler
        <span class="apidocSignatureSpan">(async)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Scheduler(async) {
		this._async = async;
		this._running = false;

		this._queue = this;
		this._queueLen = 0;
		this._afterQueue = {};
		this._afterQueueLen = 0;

		var self = this;
		this.drain = function() {
			self._drain();
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.TimeoutError" id="apidoc.element.when.TimeoutError">
        function <span class="apidocSignatureSpan">when.</span>TimeoutError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimeoutError(message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === 'function') {
			Error.captureStackTrace(this, TimeoutError);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.all" id="apidoc.element.when.all">
        function <span class="apidocSignatureSpan">when.</span>all
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function all(promises) {
		return when(promises, Promise.all);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 *
	 * @deprecated
	 */
	function promisify(asyncFunction, positions) {

		return function() {
			var thisArg = this;
			return Promise.<span class="apidocCodeKeywordSpan">all</span>(arguments).then(function(args) {
				var p = Promise._defer();

				var callbackPos, errbackPos;

				if(typeof positions.callback === 'number') {
					callbackPos = normalizePosition(args, positions.callback);
				}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.any" id="apidoc.element.when.any">
        function <span class="apidocSignatureSpan">when.</span>any
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">any = function () {
			for(var i=0, l=arguments.length, a=new Array(l); i&lt;l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* `promise.otherwise(errback)` as a shortcut for `promise.then(null, errback)`. See discussion [here](https://github.com/cujojs/
when/issues/13) and [here](https://github.com/cujojs/when/issues/29). Thanks to [@jonnyreeves](https://github.com/jonnyreeves/)
for suggesting the name "otherwise".
* [when/debug](https://github.com/cujojs/when/wiki/when-debug) now detects exceptions that typically represent coding errors, such
 as SyntaxError, ReferenceError, etc. and propagates them to the host environment.  In other words, you'll get a very loud
stack trace.

### 1.1.1

* Updated [wiki](https://github.com/cujojs/when/wiki) map/reduce examples, and added simple promise forwarding example
* Fix for calling `when.<span class="apidocCodeKeywordSpan">any</span>()` without a callback ([#33](https://github.com/cujojs/when
/issues/33))
* Fix version number in `when.js` source ([#36](https://github.com/cujojs/when/issues/36))

### 1.1.0

* `when.all/any/some/map/reduce` can all now accept a promise for an array in addition to an actual array as input.  This allows
 composing functions to do interesting things like `when.reduce(when.map(...))`
* `when.reject(promiseOrValue)` that returns a new, rejected promise.
* `promise.always(callback)` as a shortcut for `promise.then(callback, callback)`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.apply" id="apidoc.element.when.apply">
        function <span class="apidocSignatureSpan">when.</span>apply
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function apply() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 * Takes a `traditional` callback-taking function and returns a promise for its
	 * result, accepting an optional array of arguments (that might be values or
	 * promises). It assumes that the function takes its callback and errback as
	 * the last two arguments. The resolution of the promise depends on whether the
	 * function will call its callback or its errback.
	 *
	 * @example
	 *    var domIsLoaded = callbacks.<span class="apidocCodeKeywordSpan">apply</span>($);
	 *    domIsLoaded.then(function() {
	 *		doMyDomStuff();
	 *	});
	 *
	 * @example
	 *    function existingAjaxyFunction(url, callback, errback) {
	 *		// Complex logic you'd rather not change
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.attempt" id="apidoc.element.when.attempt">
        function <span class="apidocSignatureSpan">when.</span>attempt
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attempt(f) {
		<span class="apidocCodeCommentSpan">/*jshint validthis:true */
</span>		for(var i=0, l=arguments.length-1, a=new Array(l); i&lt;l; ++i) {
			a[i] = arguments[i+1];
		}
		return apply(f, this, a);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.defer" id="apidoc.element.when.defer">
        function <span class="apidocSignatureSpan">when.</span>defer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defer() {
		return new Deferred();
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Decorator that makes a deferred "cancelable".  It adds a cancel() method that
 * will call a special cancel handler function and then reject the deferred.  The
 * cancel handler can be used to do resource cleanup, or anything else that should
 * be done before any other rejection handlers are executed.
 *
 * Usage:
 *
 * var cancelableDeferred = cancelable(when.<span class="apidocCodeKeywordSpan">defer</span>(), myCancelHandler);
 *
 * @author brian@hovercraftstudios.com
 */

(function(define) {
define(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.filter" id="apidoc.element.when.filter">
        function <span class="apidocSignatureSpan">when.</span>filter
        <span class="apidocSignatureSpan">(promises, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(promises, predicate) {
		return when(promises, function(promises) {
			return Promise.filter(promises, predicate);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	when.settle      = settle;               // Settle a list of promises

	when.any         = lift(Promise.any);    // One-winner race
	when.some        = lift(Promise.some);   // Multi-winner race
	when.race        = lift(Promise.race);   // First-to-settle race

	when.map         = map;                  // Array.map() for promises
	when.filter      = filter;               // Array.<span class="apidocCodeKeywordSpan">filter</span>() for promises
	when.reduce      = lift(Promise.reduce);       // Array.reduce() for promises
	when.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises

	when.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable

	when.Promise     = Promise;              // Promise constructor
	when.defer       = defer;                // Create a {promise, resolve, reject} tuple
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.guard" id="apidoc.element.when.guard">
        function <span class="apidocSignatureSpan">when.</span>guard
        <span class="apidocSignatureSpan">(condition, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function guard(condition, f) {
		return function() {
			var args = slice.call(arguments);

			return when(condition()).withThis(this).then(function(exit) {
				return when(f.apply(this, args))['finally'](exit);
			});
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.isPromiseLike" id="apidoc.element.when.isPromiseLike">
        function <span class="apidocSignatureSpan">when.</span>isPromiseLike
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPromiseLike(x) {
		return x &amp;&amp; typeof x.then === 'function';
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.iterate" id="apidoc.element.when.iterate">
        function <span class="apidocSignatureSpan">when.</span>iterate
        <span class="apidocSignatureSpan">(f, condition, handler, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function iterate(f, condition, handler, x) {
			return unfold(function(x) {
				return [x, f(x)];
			}, condition, handler, x);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.join" id="apidoc.element.when.join">
        function <span class="apidocSignatureSpan">when.</span>join
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function join() {
		return Promise.all(arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		 * @param {function=} onFulfilled fulfillment handler
		 * @param {function=} onRejected rejection handler
		 * @param {function=} onProgress @deprecated progress handler
		 * @return {Promise} new promise
		 */
		Promise.prototype.then = function(onFulfilled, onRejected, onProgress) {
			var parent = this._handler;
			var state = parent.<span class="apidocCodeKeywordSpan">join</span>().state();

			if ((typeof onFulfilled !== 'function' &amp;&amp; state &gt; 0) ||
				(typeof onRejected !== 'function' &amp;&amp; state &lt; 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.constructor(Handler, parent);
			}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.lift" id="apidoc.element.when.lift">
        function <span class="apidocSignatureSpan">when.</span>lift
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lift(f) {
		return function() {
			for(var i=0, l=arguments.length, a=new Array(l); i&lt;l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 *
	 *		xhr.onload = callback;
	 *		xhr.onerror = errback;
	 *
	 *		xhr.send();
	 *	}
	 *
	 *    var promiseAjax = callbacks.<span class="apidocCodeKeywordSpan">lift</span>(traditionalAjax);
	 *    promiseAjax("GET", "/movies.json").then(console.log, console.error);
	 *
	 *    var promiseAjaxGet = callbacks.lift(traditionalAjax, "GET");
	 *    promiseAjaxGet("/movies.json").then(console.log, console.error);
	 *
	 * @param {Function} f traditional async function to be decorated
	 * @param {...*} [args] arguments to be prepended for the new function @deprecated
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.map" id="apidoc.element.when.map">
        function <span class="apidocSignatureSpan">when.</span>map
        <span class="apidocSignatureSpan">(promises, mapFunc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(promises, mapFunc) {
		return when(promises, function(promises) {
			return Promise.map(promises, mapFunc);
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* Updated [wiki](https://github.com/cujojs/when/wiki) map/reduce examples, and added simple promise forwarding example
* Fix for calling `when.any()` without a callback ([#33](https://github.com/cujojs/when/issues/33))
* Fix version number in `when.js` source ([#36](https://github.com/cujojs/when/issues/36))

### 1.1.0

* `when.all/any/some/map/reduce` can all now accept a promise for an array in addition to an actual array as input.  This allows
 composing functions to do interesting things like `when.reduce(when.<span class="apidocCodeKeywordSpan">map</span>(...))`
* `when.reject(promiseOrValue)` that returns a new, rejected promise.
* `promise.always(callback)` as a shortcut for `promise.then(callback, callback)`
* **Highly experimental** [when/debug](https://github.com/cujojs/when/wiki/when-debug) module: a drop-in replacement for the main
 `when` module that enables debug logging for promises created or consumed by when.js

### 1.0.4

* [Travis CI](http://travis-ci.org/cujojs/when) integration
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.promise" id="apidoc.element.when.promise">
        function <span class="apidocSignatureSpan">when.</span>promise
        <span class="apidocSignatureSpan">(resolver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promise(resolver) {
		return new Promise(resolver);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Fix for `when.defer().reject()` bypassing the unhandled rejection monitor. (#166)
* Fix for `when/function`, `when/callbacks`, and `when/node/function` not preserving `thisArg`. (#162)
* Doc clarifications for [`promise.yield`](docs/api.md#yield). (#164)

### 2.2.0

* New experimental [promise monitoring and debugging](docs.md#debugging-promises) via `when/monitor/console`.
* New [`when.<span class="apidocCodeKeywordSpan">promise</span>(resolver)`](docs/api.md#whenpromise) promise creation API. A lighter
 alternative to the heavier `when.defer()`
* New `bindCallback` and `liftCallback` in `when/node/function` for more integration options with node-style callbacks.

### 2.1.1

* Quote internal usages of `promise.yield` to workaround .NET minifier tools that don't yet understand ES5 identifier-as-property
 rules.  See [#157](https://github.com/cujojs/when/issues/157)

### 2.1.0
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.race" id="apidoc.element.when.race">
        function <span class="apidocSignatureSpan">when.</span>race
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">race = function () {
			for(var i=0, l=arguments.length, a=new Array(l); i&lt;l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.reduce" id="apidoc.element.when.reduce">
        function <span class="apidocSignatureSpan">when.</span>reduce
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reduce = function () {
			for(var i=0, l=arguments.length, a=new Array(l); i&lt;l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* Updated [wiki](https://github.com/cujojs/when/wiki) map/reduce examples, and added simple promise forwarding example
* Fix for calling `when.any()` without a callback ([#33](https://github.com/cujojs/when/issues/33))
* Fix version number in `when.js` source ([#36](https://github.com/cujojs/when/issues/36))

### 1.1.0

* `when.all/any/some/map/reduce` can all now accept a promise for an array in addition to an actual array as input.  This allows
 composing functions to do interesting things like `when.<span class="apidocCodeKeywordSpan">reduce</span>(when.map(...))`
* `when.reject(promiseOrValue)` that returns a new, rejected promise.
* `promise.always(callback)` as a shortcut for `promise.then(callback, callback)`
* **Highly experimental** [when/debug](https://github.com/cujojs/when/wiki/when-debug) module: a drop-in replacement for the main
 `when` module that enables debug logging for promises created or consumed by when.js

### 1.0.4

* [Travis CI](http://travis-ci.org/cujojs/when) integration
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.reduceRight" id="apidoc.element.when.reduceRight">
        function <span class="apidocSignatureSpan">when.</span>reduceRight
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reduceRight = function () {
			for(var i=0, l=arguments.length, a=new Array(l); i&lt;l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	when.any         = lift(Promise.any);    // One-winner race
	when.some        = lift(Promise.some);   // Multi-winner race
	when.race        = lift(Promise.race);   // First-to-settle race

	when.map         = map;                  // Array.map() for promises
	when.filter      = filter;               // Array.filter() for promises
	when.reduce      = lift(Promise.reduce);       // Array.reduce() for promises
	when.reduceRight = lift(Promise.reduceRight);  // Array.<span class="apidocCodeKeywordSpan">reduceRight</span>() for promises

	when.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable

	when.Promise     = Promise;              // Promise constructor
	when.defer       = defer;                // Create a {promise, resolve, reject} tuple

	// Error types
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.reject" id="apidoc.element.when.reject">
        function <span class="apidocSignatureSpan">when.</span>reject
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reject(x) {
			return new Promise(Handler, new Async(new Rejected(x)));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		tryCatchResolve(f, thisArg, args, h);
	}

	function tryCatchResolve(f, thisArg, args, resolver) {
		try {
			f.apply(thisArg, args);
		} catch(e) {
			resolver.<span class="apidocCodeKeywordSpan">reject</span>(e);
		}
	}

	/**
	 * Works as `callbacks.apply` does, with the difference that the arguments to
	 * the function are passed individually, instead of as an array.
	 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.resolve" id="apidoc.element.when.resolve">
        function <span class="apidocSignatureSpan">when.</span>resolve
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve(x) {
			return isPromise(x) ? x
				: new Promise(Handler, new Async(getHandler(x)));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### 1.8.1

* Last 1.x.x release before 2.0.0 barring critical fixes.
	* To prepare for 2.0.0, [test your code against the dev-200 branch](https://github.com/cujojs/when/tree/dev-200). It is fully API
 compatible, but has fully asynchronous resolutions.
* Performance improvements for [when/function](docs/api.md#synchronous-functions).
* [Documentation](docs/api.md) updates and fixes. Thanks, [@unscriptable](https://github.com/unscriptable)!
* **DEPRECATED:** `deferred.progress` and `deferred.resolver.progress`. Use [`deferred.notify`](docs/api.md#progress-events) and
 [`deferred.resolver.notify`](docs/api.md#progress-events) instead.
* **DEPRECATED:** [`when.chain`](docs/api.md#whenchain). Use [`resolver.<span class="apidocCodeKeywordSpan">resolve</span>(promise
)`](docs/api.md#resolver) or `resolver.resolve(promise.yield)` ([see `promise.yield`](docs/api.md#yield)) instead.
* **DEPRECATED:** `when/timed` module.  Use [`when/delay`](docs/api.md#whendelay) and [`when/timeout`](docs/api.md#whentimeout)
modules instead.

### 1.8.0

* New [when/function](docs/api.md#synchronous-functions), [when/node/function](docs/api.md#node-style-asynchronous-functions), and
 [when/callbacks](docs/api.md#asynchronous-functions) with functional programming goodness, and adapters for turning callback-based
 APIs into promise-based APIs. Kudos [@riccieri](https://github.com/riccieri)!
* New [when/unfold](docs/api.md#whenunfold), and [when/unfold/list](docs/api.md#whenunfoldlist) promise-aware anamorphic unfolds
 that can be used to generate and/or process unbounded lists.
* New [when/poll](docs/api.md#whenpoll) promise-based periodic polling and task execution. Kudos [@scothis](https://github.com/scothis
)!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.settle" id="apidoc.element.when.settle">
        function <span class="apidocSignatureSpan">when.</span>settle
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function settle(promises) {
		return when(promises, Promise.settle);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			return toPromise(results);
		}

		var p = Promise._defer();
		var resolver = Promise._handler(p);
		var promises = keys.map(function(k) { return object[k]; });

		when.<span class="apidocCodeKeywordSpan">settle</span>(promises).then(function(states) {
			populateResults(keys, states, results, resolver);
		});

		return p;
	}

	function populateResults(keys, states, results, resolver) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.some" id="apidoc.element.when.some">
        function <span class="apidocSignatureSpan">when.</span>some
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">some = function () {
			for(var i=0, l=arguments.length, a=new Array(l); i&lt;l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### 3.3.1

* Fix argument ordering bug in `when/node` introduced in 3.3.0.

### 3.3.0

* Promote [`when.race`](docs/api.md#whenrace) to public API.
* `when.any` and `when.some` now reject with a `RangeError` if the race is obviously unwinnable, for example: `when.<span class="
apidocCodeKeywordSpan">some</span>([1,2,3], 4)`.  See the [`when.any`](docs/api.md#whenany) and [`when.some`](docs/api.md#whensome
) docs for more info.

### 3.2.3

* Updated [debugging docs](docs/api.md#debugging-promises)
* Report when previously unhandled rejections become handled, with an ID to correlate the two messages.
* Improve unhandled rejection reporting for cases where multiple different promise implementations interleave.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.try" id="apidoc.element.when.try">
        function <span class="apidocSignatureSpan">when.</span>try
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attempt(f) {
		<span class="apidocCodeCommentSpan">/*jshint validthis:true */
</span>		for(var i=0, l=arguments.length-1, a=new Array(l); i&lt;l; ++i) {
			a[i] = arguments[i+1];
		}
		return apply(f, this, a);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.unfold" id="apidoc.element.when.unfold">
        function <span class="apidocSignatureSpan">when.</span>unfold
        <span class="apidocSignatureSpan">(unspool, condition, handler, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unfold(unspool, condition, handler, x) {
			return resolve(x).then(function(seed) {
				return resolve(condition(seed)).then(function(done) {
					return done ? seed : resolve(unspool(seed)).spread(next);
				});
			});

			function next(item, newSeed) {
				return resolve(handler(item)).then(function() {
					return unfold(unspool, condition, handler, newSeed);
				});
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.ConsoleReporter" id="apidoc.module.when.ConsoleReporter">module when.ConsoleReporter</a></h1>


    <h2>
        <a href="#apidoc.element.when.ConsoleReporter.ConsoleReporter" id="apidoc.element.when.ConsoleReporter.ConsoleReporter">
        function <span class="apidocSignatureSpan">when.</span>ConsoleReporter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConsoleReporter() {
		this._previouslyReported = false;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.ConsoleReporter.prototype" id="apidoc.module.when.ConsoleReporter.prototype">module when.ConsoleReporter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.when.ConsoleReporter.prototype._log" id="apidoc.element.when.ConsoleReporter.prototype._log">
        function <span class="apidocSignatureSpan">when.ConsoleReporter.prototype.</span>_log
        <span class="apidocSignatureSpan">(traces)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_log = function (traces) {
		for(var i=0; i&lt;traces.length; ++i) {
			this.warn(error.format(traces[i]));
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
			return;
		}

		this._previouslyReported = true;
		this.groupStart(unhandledRejectionsMsg + traces.length);
		try {
			this.<span class="apidocCodeKeywordSpan">_log</span>(traces);
		} finally {
			this.groupEnd();
		}
	};

	ConsoleReporter.prototype._log = function(traces) {
		for(var i=0; i&lt;traces.length; ++i) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.ConsoleReporter.prototype.groupEnd" id="apidoc.element.when.ConsoleReporter.prototype.groupEnd">
        function <span class="apidocSignatureSpan">when.ConsoleReporter.prototype.</span>groupEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function consoleNotAvailable() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}

		this._previouslyReported = true;
		this.groupStart(unhandledRejectionsMsg + traces.length);
		try {
			this._log(traces);
		} finally {
			this.<span class="apidocCodeKeywordSpan">groupEnd</span>();
		}
	};

	ConsoleReporter.prototype._log = function(traces) {
		for(var i=0; i&lt;traces.length; ++i) {
			this.warn(error.format(traces[i]));
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.ConsoleReporter.prototype.groupStart" id="apidoc.element.when.ConsoleReporter.prototype.groupStart">
        function <span class="apidocSignatureSpan">when.ConsoleReporter.prototype.</span>groupStart
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupStart = function (s) {
					localConsole.error(s);
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				this._previouslyReported = false;
				this.msg(allHandledMsg);
			}
			return;
		}

		this._previouslyReported = true;
		this.<span class="apidocCodeKeywordSpan">groupStart</span>(unhandledRejectionsMsg + traces.length);
		try {
			this._log(traces);
		} finally {
			this.groupEnd();
		}
	};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.ConsoleReporter.prototype.log" id="apidoc.element.when.ConsoleReporter.prototype.log">
        function <span class="apidocSignatureSpan">when.ConsoleReporter.prototype.</span>log
        <span class="apidocSignatureSpan">(traces)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (traces) {
		if(traces.length === 0) {
			if(this._previouslyReported) {
				this._previouslyReported = false;
				this.msg(allHandledMsg);
			}
			return;
		}

		this._previouslyReported = true;
		this.groupStart(unhandledRejectionsMsg + traces.length);
		try {
			this._log(traces);
		} finally {
			this.groupEnd();
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 *
	 * @example
	 *    var delay = callbacks.promisify(setTimeout, {
	 *		callback: 0
	 *	});
	 *
	 *    delay(100).then(function() {
	 *		console.<span class="apidocCodeKeywordSpan">log</span>("This happens 100ms afterwards");
	 *	});
	 *
	 * @example
	 *    function callbackAsLast(errback, followsStandards, callback) {
	 *		if(followsStandards) {
	 *			callback("well done!");
	 *		} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.ConsoleReporter.prototype.msg" id="apidoc.element.when.ConsoleReporter.prototype.msg">
        function <span class="apidocSignatureSpan">when.ConsoleReporter.prototype.</span>msg
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">msg = function (s) {
					localConsole.log(s);
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	ConsoleReporter.prototype = initDefaultLogging();

	ConsoleReporter.prototype.log = function(traces) {
		if(traces.length === 0) {
			if(this._previouslyReported) {
				this._previouslyReported = false;
				this.<span class="apidocCodeKeywordSpan">msg</span>(allHandledMsg);
			}
			return;
		}

		this._previouslyReported = true;
		this.groupStart(unhandledRejectionsMsg + traces.length);
		try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.ConsoleReporter.prototype.warn" id="apidoc.element.when.ConsoleReporter.prototype.warn">
        function <span class="apidocSignatureSpan">when.ConsoleReporter.prototype.</span>warn
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">warn = function (s) {
					localConsole.error(s);
				}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} finally {
			this.groupEnd();
		}
	};

	ConsoleReporter.prototype._log = function(traces) {
		for(var i=0; i&lt;traces.length; ++i) {
			this.<span class="apidocCodeKeywordSpan">warn</span>(error.format(traces[i]));
		}
	};

	function initDefaultLogging() {
		/*jshint maxcomplexity:7*/
		var log, warn, groupStart, groupEnd;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.Promise" id="apidoc.module.when.Promise">module when.Promise</a></h1>


    <h2>
        <a href="#apidoc.element.when.Promise.Promise" id="apidoc.element.when.Promise.Promise">
        function <span class="apidocSignatureSpan">when.</span>Promise
        <span class="apidocSignatureSpan">(resolver, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise._defer" id="apidoc.element.when.Promise._defer">
        function <span class="apidocSignatureSpan">when.Promise.</span>_defer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defer() {
			return new Promise(Handler, new Pending());
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 * @deprecated
	 */
	function promisify(asyncFunction, positions) {

		return function() {
			var thisArg = this;
			return Promise.all(arguments).then(function(args) {
				var p = Promise.<span class="apidocCodeKeywordSpan">_defer</span>();

				var callbackPos, errbackPos;

				if(typeof positions.callback === 'number') {
					callbackPos = normalizePosition(args, positions.callback);
				}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise._handler" id="apidoc.element.when.Promise._handler">
        function <span class="apidocSignatureSpan">when.Promise.</span>_handler
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHandler(x) {
			if(isPromise(x)) {
				return x._handler.join();
			}
			return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}

	function handle(result, iterator) {
		if(result.done) {
			return result.value;
		}

		var h = Promise.<span class="apidocCodeKeywordSpan">_handler</span>(result.value);
		if(h.state() &gt; 0) {
			return runNext(h.value, iterator);
		}

		var p = Promise._defer();
		h.chain(p._handler, iterator, next, error);
		return p;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise._traverse" id="apidoc.element.when.Promise._traverse">
        function <span class="apidocSignatureSpan">when.Promise.</span>_traverse
        <span class="apidocSignatureSpan">(f, promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function traverse(f, promises) {
			return traverseWith(tryCatch2, f, promises);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		 * Apply f to the value of each promise in a list of promises
		 * and return a new list containing the results.
		 * @param {array} promises
		 * @param {function(x:*, index:Number):*} f mapping function
		 * @returns {Promise}
		 */
		function map(promises, f) {
			return Promise.<span class="apidocCodeKeywordSpan">_traverse</span>(f, promises);
		}

		/**
		 * Filter the provided array of promises using the provided predicate.  Input may
		 * contain promises and values
		 * @param {Array} promises array of promises and values
		 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise._visitRemaining" id="apidoc.element.when.Promise._visitRemaining">
        function <span class="apidocSignatureSpan">when.Promise.</span>_visitRemaining
        <span class="apidocSignatureSpan">(promises, start, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function visitRemaining(promises, start, handler) {
			for(var i=start; i&lt;promises.length; ++i) {
				markAsHandled(getHandler(promises[i]), handler);
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					--pending;
					continue;
				}

				h = Promise._handler(x);
				if(h.state() &gt; 0) {
					resolver.become(h);
					Promise.<span class="apidocCodeKeywordSpan">_visitRemaining</span>(promises, i, h);
					break;
				} else {
					h.visit(resolver, handleFulfill, handleReject);
				}
			}

			if(pending === 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.all" id="apidoc.element.when.Promise.all">
        function <span class="apidocSignatureSpan">when.Promise.</span>all
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function all(promises) {
			return traverseWith(snd, null, promises);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 *
	 * @deprecated
	 */
	function promisify(asyncFunction, positions) {

		return function() {
			var thisArg = this;
			return Promise.<span class="apidocCodeKeywordSpan">all</span>(arguments).then(function(args) {
				var p = Promise._defer();

				var callbackPos, errbackPos;

				if(typeof positions.callback === 'number') {
					callbackPos = normalizePosition(args, positions.callback);
				}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.any" id="apidoc.element.when.Promise.any">
        function <span class="apidocSignatureSpan">when.Promise.</span>any
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function any(promises) {
			var p = Promise._defer();
			var resolver = p._handler;
			var l = promises.length&gt;&gt;&gt;0;

			var pending = l;
			var errors = [];

			for (var h, x, i = 0; i &lt; l; ++i) {
				x = promises[i];
				if(x === void 0 &amp;&amp; !(i in promises)) {
					--pending;
					continue;
				}

				h = Promise._handler(x);
				if(h.state() &gt; 0) {
					resolver.become(h);
					Promise._visitRemaining(promises, i, h);
					break;
				} else {
					h.visit(resolver, handleFulfill, handleReject);
				}
			}

			if(pending === 0) {
				resolver.reject(new RangeError('any(): array must not be empty'));
			}

			return p;

			function handleFulfill(x) {
				<span class="apidocCodeCommentSpan">/*jshint validthis:true*/
</span>				errors = null;
				this.resolve(x); // this === resolver
			}

			function handleReject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--pending === 0) {
					this.reject(errors);
				}
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* `promise.otherwise(errback)` as a shortcut for `promise.then(null, errback)`. See discussion [here](https://github.com/cujojs/
when/issues/13) and [here](https://github.com/cujojs/when/issues/29). Thanks to [@jonnyreeves](https://github.com/jonnyreeves/)
for suggesting the name "otherwise".
* [when/debug](https://github.com/cujojs/when/wiki/when-debug) now detects exceptions that typically represent coding errors, such
 as SyntaxError, ReferenceError, etc. and propagates them to the host environment.  In other words, you'll get a very loud
stack trace.

### 1.1.1

* Updated [wiki](https://github.com/cujojs/when/wiki) map/reduce examples, and added simple promise forwarding example
* Fix for calling `when.<span class="apidocCodeKeywordSpan">any</span>()` without a callback ([#33](https://github.com/cujojs/when
/issues/33))
* Fix version number in `when.js` source ([#36](https://github.com/cujojs/when/issues/36))

### 1.1.0

* `when.all/any/some/map/reduce` can all now accept a promise for an array in addition to an actual array as input.  This allows
 composing functions to do interesting things like `when.reduce(when.map(...))`
* `when.reject(promiseOrValue)` that returns a new, rejected promise.
* `promise.always(callback)` as a shortcut for `promise.then(callback, callback)`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.createContext" id="apidoc.element.when.Promise.createContext">
        function <span class="apidocSignatureSpan">when.Promise.</span>createContext
        <span class="apidocSignatureSpan">(p, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createContext = function (p, context) {
			p.context = self.createContext(p, context);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		var failIfRejected = new FailIfRejected();

		/**
		 * Handler that manages a queue of consumers waiting on a pending promise
		 * @constructor
		 */
		function Pending(receiver, inheritedContext) {
			Promise.<span class="apidocCodeKeywordSpan">createContext</span>(this, inheritedContext);

			this.consumers = void 0;
			this.receiver = receiver;
			this.handler = void 0;
			this.resolved = false;
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.enterContext" id="apidoc.element.when.Promise.enterContext">
        function <span class="apidocSignatureSpan">when.Promise.</span>enterContext
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enterContext = function (p) {
			executionContext.push(p.context);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}

		function runContinuation1(f, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.<span class="apidocCodeKeywordSpan">enterContext</span>(h);
			tryCatchReject(f, h.value, receiver, next);
			Promise.exitContext();
		}

		function runContinuation3(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.exitContext" id="apidoc.element.when.Promise.exitContext">
        function <span class="apidocSignatureSpan">when.Promise.</span>exitContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exitContext = function () {
			executionContext.pop();
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		function runContinuation1(f, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject(f, h.value, receiver, next);
			Promise.<span class="apidocCodeKeywordSpan">exitContext</span>();
		}

		function runContinuation3(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.filter" id="apidoc.element.when.Promise.filter">
        function <span class="apidocSignatureSpan">when.Promise.</span>filter
        <span class="apidocSignatureSpan">(promises, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(promises, predicate) {
			var a = slice.call(promises);
			return Promise._traverse(predicate, a).then(function(keep) {
				return filterSync(a, keep);
			});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	when.settle      = settle;               // Settle a list of promises

	when.any         = lift(Promise.any);    // One-winner race
	when.some        = lift(Promise.some);   // Multi-winner race
	when.race        = lift(Promise.race);   // First-to-settle race

	when.map         = map;                  // Array.map() for promises
	when.filter      = filter;               // Array.<span class="apidocCodeKeywordSpan">filter</span>() for promises
	when.reduce      = lift(Promise.reduce);       // Array.reduce() for promises
	when.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises

	when.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable

	when.Promise     = Promise;              // Promise constructor
	when.defer       = defer;                // Create a {promise, resolve, reject} tuple
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.iterate" id="apidoc.element.when.Promise.iterate">
        function <span class="apidocSignatureSpan">when.Promise.</span>iterate
        <span class="apidocSignatureSpan">(f, condition, handler, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function iterate(f, condition, handler, x) {
			return unfold(function(x) {
				return [x, f(x)];
			}, condition, handler, x);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.map" id="apidoc.element.when.Promise.map">
        function <span class="apidocSignatureSpan">when.Promise.</span>map
        <span class="apidocSignatureSpan">(promises, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(promises, f) {
			return Promise._traverse(f, promises);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* Updated [wiki](https://github.com/cujojs/when/wiki) map/reduce examples, and added simple promise forwarding example
* Fix for calling `when.any()` without a callback ([#33](https://github.com/cujojs/when/issues/33))
* Fix version number in `when.js` source ([#36](https://github.com/cujojs/when/issues/36))

### 1.1.0

* `when.all/any/some/map/reduce` can all now accept a promise for an array in addition to an actual array as input.  This allows
 composing functions to do interesting things like `when.reduce(when.<span class="apidocCodeKeywordSpan">map</span>(...))`
* `when.reject(promiseOrValue)` that returns a new, rejected promise.
* `promise.always(callback)` as a shortcut for `promise.then(callback, callback)`
* **Highly experimental** [when/debug](https://github.com/cujojs/when/wiki/when-debug) module: a drop-in replacement for the main
 `when` module that enables debug logging for promises created or consumed by when.js

### 1.0.4

* [Travis CI](http://travis-ci.org/cujojs/when) integration
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.never" id="apidoc.element.when.Promise.never">
        function <span class="apidocSignatureSpan">when.Promise.</span>never
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function never() {
			return foreverPendingPromise; // Should be frozen
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		/**
		 * Fulfill-reject competitive race. Return a promise that will settle
		 * to the same state as the earliest input promise to settle.
		 *
		 * WARNING: The ES6 Promise spec requires that race()ing an empty array
		 * must return a promise that is pending forever.  This implementation
		 * returns a singleton forever-pending promise, the same singleton that is
		 * returned by Promise.<span class="apidocCodeKeywordSpan">never</span>(), thus can be checked with ===
		 *
		 * @param {array} promises array of promises to race
		 * @returns {Promise} if input is non-empty, a promise that will settle
		 * to the same outcome as the earliest input promise to settle. if empty
		 * is empty, returns a promise that will never settle.
		 */
		function race(promises) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.onFatalRejection" id="apidoc.element.when.Promise.onFatalRejection">
        function <span class="apidocSignatureSpan">when.Promise.</span>onFatalRejection
        <span class="apidocSignatureSpan">(rejection, extraContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onFatalRejection = function (rejection, extraContext) {
			return self.fatal(rejection, extraContext);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			this.handled = true;
			tasks.afterQueue(new UnreportTask(this));
		};

		Rejected.prototype.fail = function(context) {
			this.reported = true;
			emitRejection('unhandledRejection', this);
			Promise.<span class="apidocCodeKeywordSpan">onFatalRejection</span>(this, context === void 0 ? this.context : context);
		};

		function ReportTask(rejection, context) {
			this.rejection = rejection;
			this.context = context;
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.onPotentiallyUnhandledRejection" id="apidoc.element.when.Promise.onPotentiallyUnhandledRejection">
        function <span class="apidocSignatureSpan">when.Promise.</span>onPotentiallyUnhandledRejection
        <span class="apidocSignatureSpan">(rejection, extraContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onPotentiallyUnhandledRejection = function (rejection, extraContext) {
			return self.addTrace(rejection, extraContext);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			this.context = context;
		}

		ReportTask.prototype.run = function() {
			if(!this.rejection.handled &amp;&amp; !this.rejection.reported) {
				this.rejection.reported = true;
				emitRejection('unhandledRejection', this.rejection) ||
					Promise.<span class="apidocCodeKeywordSpan">onPotentiallyUnhandledRejection</span>(this.rejection, this.context);
			}
		};

		function UnreportTask(rejection) {
			this.rejection = rejection;
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.onPotentiallyUnhandledRejectionHandled" id="apidoc.element.when.Promise.onPotentiallyUnhandledRejectionHandled">
        function <span class="apidocSignatureSpan">when.Promise.</span>onPotentiallyUnhandledRejectionHandled
        <span class="apidocSignatureSpan">(rejection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onPotentiallyUnhandledRejectionHandled = function (rejection) {
			return self.removeTrace(rejection);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		function UnreportTask(rejection) {
			this.rejection = rejection;
		}

		UnreportTask.prototype.run = function() {
			if(this.rejection.reported) {
				emitRejection('rejectionHandled', this.rejection) ||
					Promise.<span class="apidocCodeKeywordSpan">onPotentiallyUnhandledRejectionHandled</span>(this.rejection);
			}
		};

		// Unhandled rejection hooks
		// By default, everything is a noop

		Promise.createContext
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.race" id="apidoc.element.when.Promise.race">
        function <span class="apidocSignatureSpan">when.Promise.</span>race
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function race(promises) {
			if(typeof promises !== 'object' || promises === null) {
				return reject(new TypeError('non-iterable passed to race()'));
			}

			// Sigh, race([]) is untestable unless we return *something*
			// that is recognizable without calling .then() on it.
			return promises.length === 0 ? never()
				 : promises.length === 1 ? resolve(promises[0])
				 : runRace(promises);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.reduce" id="apidoc.element.when.Promise.reduce">
        function <span class="apidocSignatureSpan">when.Promise.</span>reduce
        <span class="apidocSignatureSpan">(promises, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(promises, f) {
			return arguments.length &gt; 2 ? ar.call(promises, liftCombine(f), arguments[2])
					: ar.call(promises, liftCombine(f));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* Updated [wiki](https://github.com/cujojs/when/wiki) map/reduce examples, and added simple promise forwarding example
* Fix for calling `when.any()` without a callback ([#33](https://github.com/cujojs/when/issues/33))
* Fix version number in `when.js` source ([#36](https://github.com/cujojs/when/issues/36))

### 1.1.0

* `when.all/any/some/map/reduce` can all now accept a promise for an array in addition to an actual array as input.  This allows
 composing functions to do interesting things like `when.<span class="apidocCodeKeywordSpan">reduce</span>(when.map(...))`
* `when.reject(promiseOrValue)` that returns a new, rejected promise.
* `promise.always(callback)` as a shortcut for `promise.then(callback, callback)`
* **Highly experimental** [when/debug](https://github.com/cujojs/when/wiki/when-debug) module: a drop-in replacement for the main
 `when` module that enables debug logging for promises created or consumed by when.js

### 1.0.4

* [Travis CI](http://travis-ci.org/cujojs/when) integration
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.reduceRight" id="apidoc.element.when.Promise.reduceRight">
        function <span class="apidocSignatureSpan">when.Promise.</span>reduceRight
        <span class="apidocSignatureSpan">(promises, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(promises, f) {
			return arguments.length &gt; 2 ? arr.call(promises, liftCombine(f), arguments[2])
					: arr.call(promises, liftCombine(f));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	when.any         = lift(Promise.any);    // One-winner race
	when.some        = lift(Promise.some);   // Multi-winner race
	when.race        = lift(Promise.race);   // First-to-settle race

	when.map         = map;                  // Array.map() for promises
	when.filter      = filter;               // Array.filter() for promises
	when.reduce      = lift(Promise.reduce);       // Array.reduce() for promises
	when.reduceRight = lift(Promise.reduceRight);  // Array.<span class="apidocCodeKeywordSpan">reduceRight</span>() for promises

	when.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable

	when.Promise     = Promise;              // Promise constructor
	when.defer       = defer;                // Create a {promise, resolve, reject} tuple

	// Error types
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.reject" id="apidoc.element.when.Promise.reject">
        function <span class="apidocSignatureSpan">when.Promise.</span>reject
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reject(x) {
			return new Promise(Handler, new Async(new Rejected(x)));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		tryCatchResolve(f, thisArg, args, h);
	}

	function tryCatchResolve(f, thisArg, args, resolver) {
		try {
			f.apply(thisArg, args);
		} catch(e) {
			resolver.<span class="apidocCodeKeywordSpan">reject</span>(e);
		}
	}

	/**
	 * Works as `callbacks.apply` does, with the difference that the arguments to
	 * the function are passed individually, instead of as an array.
	 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.resolve" id="apidoc.element.when.Promise.resolve">
        function <span class="apidocSignatureSpan">when.Promise.</span>resolve
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve(x) {
			return isPromise(x) ? x
				: new Promise(Handler, new Async(getHandler(x)));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### 1.8.1

* Last 1.x.x release before 2.0.0 barring critical fixes.
	* To prepare for 2.0.0, [test your code against the dev-200 branch](https://github.com/cujojs/when/tree/dev-200). It is fully API
 compatible, but has fully asynchronous resolutions.
* Performance improvements for [when/function](docs/api.md#synchronous-functions).
* [Documentation](docs/api.md) updates and fixes. Thanks, [@unscriptable](https://github.com/unscriptable)!
* **DEPRECATED:** `deferred.progress` and `deferred.resolver.progress`. Use [`deferred.notify`](docs/api.md#progress-events) and
 [`deferred.resolver.notify`](docs/api.md#progress-events) instead.
* **DEPRECATED:** [`when.chain`](docs/api.md#whenchain). Use [`resolver.<span class="apidocCodeKeywordSpan">resolve</span>(promise
)`](docs/api.md#resolver) or `resolver.resolve(promise.yield)` ([see `promise.yield`](docs/api.md#yield)) instead.
* **DEPRECATED:** `when/timed` module.  Use [`when/delay`](docs/api.md#whendelay) and [`when/timeout`](docs/api.md#whentimeout)
modules instead.

### 1.8.0

* New [when/function](docs/api.md#synchronous-functions), [when/node/function](docs/api.md#node-style-asynchronous-functions), and
 [when/callbacks](docs/api.md#asynchronous-functions) with functional programming goodness, and adapters for turning callback-based
 APIs into promise-based APIs. Kudos [@riccieri](https://github.com/riccieri)!
* New [when/unfold](docs/api.md#whenunfold), and [when/unfold/list](docs/api.md#whenunfoldlist) promise-aware anamorphic unfolds
 that can be used to generate and/or process unbounded lists.
* New [when/poll](docs/api.md#whenpoll) promise-based periodic polling and task execution. Kudos [@scothis](https://github.com/scothis
)!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.settle" id="apidoc.element.when.Promise.settle">
        function <span class="apidocSignatureSpan">when.Promise.</span>settle
        <span class="apidocSignatureSpan">(promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function settle(promises) {
			return all(promises.map(settleOne));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			return toPromise(results);
		}

		var p = Promise._defer();
		var resolver = Promise._handler(p);
		var promises = keys.map(function(k) { return object[k]; });

		when.<span class="apidocCodeKeywordSpan">settle</span>(promises).then(function(states) {
			populateResults(keys, states, results, resolver);
		});

		return p;
	}

	function populateResults(keys, states, results, resolver) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.some" id="apidoc.element.when.Promise.some">
        function <span class="apidocSignatureSpan">when.Promise.</span>some
        <span class="apidocSignatureSpan">(promises, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function some(promises, n) {
			<span class="apidocCodeCommentSpan">/*jshint maxcomplexity:7*/
</span>			var p = Promise._defer();
			var resolver = p._handler;

			var results = [];
			var errors = [];

			var l = promises.length&gt;&gt;&gt;0;
			var nFulfill = 0;
			var nReject;
			var x, i; // reused in both for() loops

			// First pass: count actual array items
			for(i=0; i&lt;l; ++i) {
				x = promises[i];
				if(x === void 0 &amp;&amp; !(i in promises)) {
					continue;
				}
				++nFulfill;
			}

			// Compute actual goals
			n = Math.max(n, 0);
			nReject = (nFulfill - n + 1);
			nFulfill = Math.min(n, nFulfill);

			if(n &gt; nFulfill) {
				resolver.reject(new RangeError('some(): array must contain at least '
				+ n + ' item(s), but had ' + nFulfill));
			} else if(nFulfill === 0) {
				resolver.resolve(results);
			}

			// Second pass: observe each array item, make progress toward goals
			for(i=0; i&lt;l; ++i) {
				x = promises[i];
				if(x === void 0 &amp;&amp; !(i in promises)) {
					continue;
				}

				Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);
			}

			return p;

			function fulfill(x) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				results.push(x);
				if(--nFulfill === 0) {
					errors = null;
					this.resolve(results);
				}
			}

			function reject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--nReject === 0) {
					results = null;
					this.reject(errors);
				}
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### 3.3.1

* Fix argument ordering bug in `when/node` introduced in 3.3.0.

### 3.3.0

* Promote [`when.race`](docs/api.md#whenrace) to public API.
* `when.any` and `when.some` now reject with a `RangeError` if the race is obviously unwinnable, for example: `when.<span class="
apidocCodeKeywordSpan">some</span>([1,2,3], 4)`.  See the [`when.any`](docs/api.md#whenany) and [`when.some`](docs/api.md#whensome
) docs for more info.

### 3.2.3

* Updated [debugging docs](docs/api.md#debugging-promises)
* Report when previously unhandled rejections become handled, with an ID to correlate the two messages.
* Improve unhandled rejection reporting for cases where multiple different promise implementations interleave.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.unfold" id="apidoc.element.when.Promise.unfold">
        function <span class="apidocSignatureSpan">when.Promise.</span>unfold
        <span class="apidocSignatureSpan">(unspool, condition, handler, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unfold(unspool, condition, handler, x) {
			return resolve(x).then(function(seed) {
				return resolve(condition(seed)).then(function(done) {
					return done ? seed : resolve(unspool(seed)).spread(next);
				});
			});

			function next(item, newSeed) {
				return resolve(handler(item)).then(function() {
					return unfold(unspool, condition, handler, newSeed);
				});
			}
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.Promise.prototype" id="apidoc.module.when.Promise.prototype">module when.Promise.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.when.Promise.prototype._beget" id="apidoc.element.when.Promise.prototype._beget">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>_beget
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_beget = function () {
			return begetFrom(this._handler, this.constructor);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

			if ((typeof onFulfilled !== 'function' &amp;&amp; state &gt; 0) ||
				(typeof onRejected !== 'function' &amp;&amp; state &lt; 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.constructor(Handler, parent);
			}

			var p = this.<span class="apidocCodeKeywordSpan">_beget</span>();
			var child = p._handler;

			parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

			return p;
		};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.catch" id="apidoc.element.when.Promise.prototype.catch">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>catch
        <span class="apidocSignatureSpan">(onRejected)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catch = function (onRejected) {
			if (arguments.length &lt; 2) {
				return origCatch.call(this, onRejected);
			}

			if(typeof onRejected !== 'function') {
				return this.ensure(rejectInvalidPredicate);
			}

			return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This first example will print `"hello world!!!!"` if all went well, or `"drat!"` if there was a problem. It
also uses [rest](https://github.com/cujojs/rest) to make an ajax request to a (fictional) external service.

```js
var rest = require('rest');

fetchRemoteGreeting()
.then(addExclamation)
.<span class="apidocCodeKeywordSpan">catch</span>(handleError)
.done(function(greeting) {
    console.log(greeting);
});

function fetchRemoteGreeting() {
// returns a when.js promise for 'hello world'
return rest('http://example.com/greeting');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.delay" id="apidoc.element.when.Promise.prototype.delay">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>delay
        <span class="apidocSignatureSpan">(ms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delay = function (ms) {
			var p = this._beget();
			this._handler.fold(handleDelay, ms, void 0, p._handler);
			return p;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

(function(define) {
define(function(require) {

	var when = require('./when');

    /**
	 * @deprecated Use when(value).<span class="apidocCodeKeywordSpan">delay</span>(ms)
     */
    return function delay(msec, value) {
		return when(value).delay(msec);
    };

});
})(typeof define === 'function' &amp;&amp; define.amd ? define : function (factory) { module.exports = factory(require
); });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.done" id="apidoc.element.when.Promise.prototype.done">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>done
        <span class="apidocSignatureSpan">(onResult, onError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">done = function (onResult, onError) {
			this._handler.visit(this._handler.receiver, onResult, onError);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
var rest = require('rest');

fetchRemoteGreeting()
    .then(addExclamation)
    .catch(handleError)
    .<span class="apidocCodeKeywordSpan">done</span>(function(greeting) {
        console.log(greeting);
    });

function fetchRemoteGreeting() {
    // returns a when.js promise for 'hello world'
    return rest('http://example.com/greeting');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.else" id="apidoc.element.when.Promise.prototype.else">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>else
        <span class="apidocSignatureSpan">(defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">else = function (defaultValue) {
			return this.then(void 0, function() {
				return defaultValue;
			});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.ensure" id="apidoc.element.when.Promise.prototype.ensure">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>ensure
        <span class="apidocSignatureSpan">(handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensure = function (handler) {
			if(typeof handler !== 'function') {
				return this;
			}

			return this.then(function(x) {
				return runSideEffect(handler, this, identity, x);
			}, function(e) {
				return runSideEffect(handler, this, reject, e);
			});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		 */
		Promise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {
			if (arguments.length &lt; 2) {
				return origCatch.call(this, onRejected);
			}

			if(typeof onRejected !== 'function') {
				return this.<span class="apidocCodeKeywordSpan">ensure</span>(rejectInvalidPredicate);
			}

			return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
		};

		/**
		 * Wraps the provided catch handler, so that it will only be called
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.finally" id="apidoc.element.when.Promise.prototype.finally">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>finally
        <span class="apidocSignatureSpan">(handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finally = function (handler) {
			if(typeof handler !== 'function') {
				return this;
			}

			return this.then(function(x) {
				return runSideEffect(handler, this, identity, x);
			}, function(e) {
				return runSideEffect(handler, this, reject, e);
			});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.fold" id="apidoc.element.when.Promise.prototype.fold">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>fold
        <span class="apidocSignatureSpan">(f, z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fold = function (f, z) {
			var promise = this._beget();

			this._handler.fold(function(z, x, to) {
				Promise._handler(z).fold(function(x, z, to) {
					to.resolve(f.call(this, z, x));
				}, x, this, to);
			}, z, promise._handler.receiver, promise._handler);

			return promise;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		var results = {};
		var keys = Object.keys(object);
		var pending = keys.length;

		for(var i=0, k; i&lt;keys.length; ++i) {
			k = keys[i];
			Promise._handler(object[k]).<span class="apidocCodeKeywordSpan">fold</span>(settleKey, k, results, resolver);
		}

		if(pending === 0) {
			resolver.resolve(results);
		}

		return p;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.inspect" id="apidoc.element.when.Promise.prototype.inspect">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
			return inspect(Promise._handler(this));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				return toPromise(p).then(state.fulfilled, state.rejected);
			}

			// The promise is our own, but it is already resolved. Take a shortcut.
			// Since we're not actually handling the resolution, we need to disable
			// rejection reporting.
			handler._unreport();
			return state.<span class="apidocCodeKeywordSpan">inspect</span>(handler);
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.orElse" id="apidoc.element.when.Promise.prototype.orElse">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>orElse
        <span class="apidocSignatureSpan">(defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">orElse = function (defaultValue) {
			return this.then(void 0, function() {
				return defaultValue;
			});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.otherwise" id="apidoc.element.when.Promise.prototype.otherwise">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>otherwise
        <span class="apidocSignatureSpan">(onRejected)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">otherwise = function (onRejected) {
			if (arguments.length &lt; 2) {
				return origCatch.call(this, onRejected);
			}

			if(typeof onRejected !== 'function') {
				return this.ensure(rejectInvalidPredicate);
			}

			return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* Fixed a deviation from the Promises/A spec where returning undefined from a callback or errback would cause the previous value
 to be forwarded.  See [#31](https://github.com/cujojs/when/issues/31)
	* *This could be a breaking change* if you depended on this behavior.  If you encounter problems, the solution is to ensure that
 your promise callbacks (registered either with `when()` or `.then()`) return what you intend, keeping in mind that not returning
 something is equivalent to returning `undefined`.
* This change also restores compatibility with the promises returned by `jQuery.get()`, which seem to reject with themselves as
the rejection value.  See [issue #41](https://github.com/cujojs/when/issues/43) for more information and discussion.  Thanks to [@
KidkArolis](https://github.com/KidkArolis) for raising the issue.

### 1.2.0

* `promise.<span class="apidocCodeKeywordSpan">otherwise</span>(errback)` as a shortcut for `promise.then(null, errback)`. See discussion
 [here](https://github.com/cujojs/when/issues/13) and [here](https://github.com/cujojs/when/issues/29). Thanks to [@jonnyreeves](
https://github.com/jonnyreeves/) for suggesting the name "otherwise".
* [when/debug](https://github.com/cujojs/when/wiki/when-debug) now detects exceptions that typically represent coding errors, such
 as SyntaxError, ReferenceError, etc. and propagates them to the host environment.  In other words, you'll get a very loud
stack trace.

### 1.1.1

* Updated [wiki](https://github.com/cujojs/when/wiki) map/reduce examples, and added simple promise forwarding example
* Fix for calling `when.any()` without a callback ([#33](https://github.com/cujojs/when/issues/33))
* Fix version number in `when.js` source ([#36](https://github.com/cujojs/when/issues/36))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.progress" id="apidoc.element.when.Promise.prototype.progress">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>progress
        <span class="apidocSignatureSpan">(onProgress)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">progress = function (onProgress) {
			return this.then(void 0, void 0, onProgress);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.spread" id="apidoc.element.when.Promise.prototype.spread">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>spread
        <span class="apidocSignatureSpan">(onFulfilled)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spread = function (onFulfilled) {
			return this.then(all).then(function(array) {
				return onFulfilled.apply(this, array);
			});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		 * @param x {*|Promise} starting value, may be a promise
		 * @return {Promise} the result of the last value produced by unspool before
		 *  condition returns true
		 */
		function unfold(unspool, condition, handler, x) {
			return resolve(x).then(function(seed) {
				return resolve(condition(seed)).then(function(done) {
					return done ? seed : resolve(unspool(seed)).<span class="apidocCodeKeywordSpan">spread</span>(next);
				});
			});

			function next(item, newSeed) {
				return resolve(handler(item)).then(function() {
					return unfold(unspool, condition, handler, newSeed);
				});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.tap" id="apidoc.element.when.Promise.prototype.tap">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>tap
        <span class="apidocSignatureSpan">(onFulfilledSideEffect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tap = function (onFulfilledSideEffect) {
			return this.then(onFulfilledSideEffect)['yield'](this);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.then" id="apidoc.element.when.Promise.prototype.then">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>then
        <span class="apidocSignatureSpan">(onFulfilled, onRejected, onProgress)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">then = function (onFulfilled, onRejected, onProgress) {
			var parent = this._handler;
			var state = parent.join().state();

			if ((typeof onFulfilled !== 'function' &amp;&amp; state &gt; 0) ||
				(typeof onRejected !== 'function' &amp;&amp; state &lt; 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.constructor(Handler, parent);
			}

			var p = this._beget();
			var child = p._handler;

			parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

			return p;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 * result, accepting an optional array of arguments (that might be values or
	 * promises). It assumes that the function takes its callback and errback as
	 * the last two arguments. The resolution of the promise depends on whether the
	 * function will call its callback or its errback.
	 *
	 * @example
	 *    var domIsLoaded = callbacks.apply($);
	 *    domIsLoaded.<span class="apidocCodeKeywordSpan">then</span>(function() {
	 *		doMyDomStuff();
	 *	});
	 *
	 * @example
	 *    function existingAjaxyFunction(url, callback, errback) {
	 *		// Complex logic you'd rather not change
	 *	}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.timeout" id="apidoc.element.when.Promise.prototype.timeout">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>timeout
        <span class="apidocSignatureSpan">(ms, reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeout = function (ms, reason) {
			var p = this._beget();
			var h = p._handler;

			var t = setTimeout(onTimeout, ms, reason, p._handler);

			this._handler.visit(h,
				function onFulfill(x) {
					env.clearTimer(t);
					this.resolve(x); // this = h
				},
				function onReject(x) {
					env.clearTimer(t);
					this.reject(x); // this = h
				},
				h.notify);

			return p;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

(function(define) {
define(function(require) {

	var when = require('./when');

    /**
	 * @deprecated Use when(trigger).<span class="apidocCodeKeywordSpan">timeout</span>(ms)
     */
    return function timeout(msec, trigger) {
		return when(trigger).timeout(msec);
    };
});
})(typeof define === 'function' &amp;&amp; define.amd ? define : function (factory) { module.exports = factory(require
); });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.with" id="apidoc.element.when.Promise.prototype.with">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>with
        <span class="apidocSignatureSpan">(receiver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">with = function (receiver) {
			var p = this._beget();
			var child = p._handler;
			child.receiver = receiver;
			this._handler.chain(child, receiver);
			return p;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.withThis" id="apidoc.element.when.Promise.prototype.withThis">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>withThis
        <span class="apidocSignatureSpan">(receiver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withThis = function (receiver) {
			var p = this._beget();
			var child = p._handler;
			child.receiver = receiver;
			this._handler.chain(child, receiver);
			return p;
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 * @param {function} f function to guard
	 * @returns {function} guarded version of f
	 */
	function guard(condition, f) {
		return function() {
			var args = slice.call(arguments);

			return when(condition()).<span class="apidocCodeKeywordSpan">withThis</span>(this).then(function(exit) {
				return when(f.apply(this, args))['finally'](exit);
			});
		};
	}

	/**
	 * Creates a condition that allows only n simultaneous executions
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Promise.prototype.yield" id="apidoc.element.when.Promise.prototype.yield">
        function <span class="apidocSignatureSpan">when.Promise.prototype.</span>yield
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">yield = function (value) {
			return this.then(function() {
				return value;
			});
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.PromiseMonitor" id="apidoc.module.when.PromiseMonitor">module when.PromiseMonitor</a></h1>


    <h2>
        <a href="#apidoc.element.when.PromiseMonitor.PromiseMonitor" id="apidoc.element.when.PromiseMonitor.PromiseMonitor">
        function <span class="apidocSignatureSpan">when.</span>PromiseMonitor
        <span class="apidocSignatureSpan">(reporter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PromiseMonitor(reporter) {
		this.logDelay = 0;
		this.stackFilter = defaultStackFilter;
		this.stackJumpSeparator = defaultStackJumpSeparator;
		this.filterDuplicateFrames = true;

		this._reporter = reporter;
		if(typeof reporter.configurePromiseMonitor === 'function') {
			reporter.configurePromiseMonitor(this);
		}

		this._traces = [];
		this._traceTask = 0;

		var self = this;
		this._doLogTraces = function() {
			self._logTraces();
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.PromiseMonitor.prototype" id="apidoc.module.when.PromiseMonitor.prototype">module when.PromiseMonitor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.when.PromiseMonitor.prototype._appendContext" id="apidoc.element.when.PromiseMonitor.prototype._appendContext">
        function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>_appendContext
        <span class="apidocSignatureSpan">(trace, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_appendContext = function (trace, context) {
		trace.push.apply(trace, this._createTrace(context));
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			return this._createLongTrace(t.handler.value, t.handler.context, t.extraContext);
		}, this);
	};

	PromiseMonitor.prototype._createLongTrace = function(e, context, extraContext) {
		var trace = error.parse(e) || [String(e) + ' (WARNING: non-Error used)'];
		trace = filterFrames(this.stackFilter, trace, 0);
		this.<span class="apidocCodeKeywordSpan">_appendContext</span>(trace, context);
		this._appendContext(trace, extraContext);
		return this.filterDuplicateFrames ? this._removeDuplicates(trace) : trace;
	};

	PromiseMonitor.prototype._removeDuplicates = function(trace) {
		var seen = {};
		var sep = this.stackJumpSeparator;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.PromiseMonitor.prototype._createLongTrace" id="apidoc.element.when.PromiseMonitor.prototype._createLongTrace">
        function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>_createLongTrace
        <span class="apidocSignatureSpan">(e, context, extraContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createLongTrace = function (e, context, extraContext) {
		var trace = error.parse(e) || [String(e) + ' (WARNING: non-Error used)'];
		trace = filterFrames(this.stackFilter, trace, 0);
		this._appendContext(trace, context);
		this._appendContext(trace, extraContext);
		return this.filterDuplicateFrames ? this._removeDuplicates(trace) : trace;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	PromiseMonitor.prototype.removeTrace = function(/*handler*/) {
		this.logTraces();
	};

	PromiseMonitor.prototype.fatal = function(handler, extraContext) {
		var err = new Error();
		err.stack = this.<span class="apidocCodeKeywordSpan">_createLongTrace</span>(handler.value, handler.context, extraContext).join
('\n');
		setTimer(function() {
			throw err;
		}, 0);
	};

	PromiseMonitor.prototype.logTraces = function() {
		if(!this._traceTask) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.PromiseMonitor.prototype._createTrace" id="apidoc.element.when.PromiseMonitor.prototype._createTrace">
        function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>_createTrace
        <span class="apidocSignatureSpan">(traceChain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_createTrace = function (traceChain) {
		var trace = [];
		var stack;

		while(traceChain) {
			stack = error.parse(traceChain);

			if (stack) {
				stack = filterFrames(this.stackFilter, stack);
				appendStack(trace, stack, this.stackJumpSeparator);
			}

			traceChain = traceChain.parent;
		}

		return trace;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				++count;
			}
			return deduped;
		}, []);
	};

	PromiseMonitor.prototype._appendContext = function(trace, context) {
		trace.push.apply(trace, this.<span class="apidocCodeKeywordSpan">_createTrace</span>(context));
	};

	PromiseMonitor.prototype._createTrace = function(traceChain) {
		var trace = [];
		var stack;

		while(traceChain) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.PromiseMonitor.prototype._logTraces" id="apidoc.element.when.PromiseMonitor.prototype._logTraces">
        function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>_logTraces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_logTraces = function () {
		this._traceTask = void 0;
		this._traces = this._traces.filter(filterHandled);
		this._reporter.log(this.formatTraces(this._traces));
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}

		this._traces = [];
		this._traceTask = 0;

		var self = this;
		this._doLogTraces = function() {
			self.<span class="apidocCodeKeywordSpan">_logTraces</span>();
		};
	}

	PromiseMonitor.prototype.monitor = function(Promise) {
		var self = this;
		Promise.createContext = function(p, context) {
			p.context = self.createContext(p, context);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.PromiseMonitor.prototype._removeDuplicates" id="apidoc.element.when.PromiseMonitor.prototype._removeDuplicates">
        function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>_removeDuplicates
        <span class="apidocSignatureSpan">(trace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_removeDuplicates = function (trace) {
		var seen = {};
		var sep = this.stackJumpSeparator;
		var count = 0;
		return trace.reduceRight(function(deduped, line, i) {
			if(i === 0) {
				deduped.unshift(line);
			} else if(line === sep) {
				if(count &gt; 0) {
					deduped.unshift(line);
					count = 0;
				}
			} else if(!seen[line]) {
				seen[line] = true;
				deduped.unshift(line);
				++count;
			}
			return deduped;
		}, []);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	};

	PromiseMonitor.prototype._createLongTrace = function(e, context, extraContext) {
		var trace = error.parse(e) || [String(e) + ' (WARNING: non-Error used)'];
		trace = filterFrames(this.stackFilter, trace, 0);
		this._appendContext(trace, context);
		this._appendContext(trace, extraContext);
		return this.filterDuplicateFrames ? this.<span class="apidocCodeKeywordSpan">_removeDuplicates</span>(trace) : trace;
	};

	PromiseMonitor.prototype._removeDuplicates = function(trace) {
		var seen = {};
		var sep = this.stackJumpSeparator;
		var count = 0;
		return trace.reduceRight(function(deduped, line, i) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.PromiseMonitor.prototype.addTrace" id="apidoc.element.when.PromiseMonitor.prototype.addTrace">
        function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>addTrace
        <span class="apidocSignatureSpan">(handler, extraContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addTrace = function (handler, extraContext) {
		var t, i;

		for(i = this._traces.length-1; i &gt;= 0; --i) {
			t = this._traces[i];
			if(t.handler === handler) {
				break;
			}
		}

		if(i &gt;= 0) {
			t.extraContext = extraContext;
		} else {
			this._traces.push({
				handler: handler,
				extraContext: extraContext
			});
		}

		this.logTraces();
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		};

		Promise.exitContext = function() {
			executionContext.pop();
		};

		Promise.onPotentiallyUnhandledRejection = function(rejection, extraContext) {
			return self.<span class="apidocCodeKeywordSpan">addTrace</span>(rejection, extraContext);
		};

		Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
			return self.removeTrace(rejection);
		};

		Promise.onFatalRejection = function(rejection, extraContext) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.PromiseMonitor.prototype.createContext" id="apidoc.element.when.PromiseMonitor.prototype.createContext">
        function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>createContext
        <span class="apidocSignatureSpan">(at, parentContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createContext = function (at, parentContext) {
		var context = {
			parent: parentContext || executionContext[executionContext.length - 1],
			stack: void 0
		};
		error.captureStack(context, at.constructor);
		return context;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		var failIfRejected = new FailIfRejected();

		/**
		 * Handler that manages a queue of consumers waiting on a pending promise
		 * @constructor
		 */
		function Pending(receiver, inheritedContext) {
			Promise.<span class="apidocCodeKeywordSpan">createContext</span>(this, inheritedContext);

			this.consumers = void 0;
			this.receiver = receiver;
			this.handler = void 0;
			this.resolved = false;
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.PromiseMonitor.prototype.fatal" id="apidoc.element.when.PromiseMonitor.prototype.fatal">
        function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>fatal
        <span class="apidocSignatureSpan">(handler, extraContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fatal = function (handler, extraContext) {
		var err = new Error();
		err.stack = this._createLongTrace(handler.value, handler.context, extraContext).join('\n');
		setTimer(function() {
			throw err;
		}, 0);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		};

		Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
			return self.removeTrace(rejection);
		};

		Promise.onFatalRejection = function(rejection, extraContext) {
			return self.<span class="apidocCodeKeywordSpan">fatal</span>(rejection, extraContext);
		};

		return this;
	};

	PromiseMonitor.prototype.createContext = function(at, parentContext) {
		var context = {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.PromiseMonitor.prototype.formatTraces" id="apidoc.element.when.PromiseMonitor.prototype.formatTraces">
        function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>formatTraces
        <span class="apidocSignatureSpan">(traces)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatTraces = function (traces) {
		return traces.map(function(t) {
			return this._createLongTrace(t.handler.value, t.handler.context, t.extraContext);
		}, this);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			this._traceTask = setTimer(this._doLogTraces, this.logDelay);
		}
	};

	PromiseMonitor.prototype._logTraces = function() {
		this._traceTask = void 0;
		this._traces = this._traces.filter(filterHandled);
		this._reporter.log(this.<span class="apidocCodeKeywordSpan">formatTraces</span>(this._traces));
	};


	PromiseMonitor.prototype.formatTraces = function(traces) {
		return traces.map(function(t) {
			return this._createLongTrace(t.handler.value, t.handler.context, t.extraContext);
		}, this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.PromiseMonitor.prototype.logTraces" id="apidoc.element.when.PromiseMonitor.prototype.logTraces">
        function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>logTraces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logTraces = function () {
		if(!this._traceTask) {
			this._traceTask = setTimer(this._doLogTraces, this.logDelay);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} else {
			this._traces.push({
				handler: handler,
				extraContext: extraContext
			});
		}

		this.<span class="apidocCodeKeywordSpan">logTraces</span>();
	};

	PromiseMonitor.prototype.removeTrace = function(/*handler*/) {
		this.logTraces();
	};

	PromiseMonitor.prototype.fatal = function(handler, extraContext) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.PromiseMonitor.prototype.monitor" id="apidoc.element.when.PromiseMonitor.prototype.monitor">
        function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>monitor
        <span class="apidocSignatureSpan">(Promise)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">monitor = function (Promise) {
		var self = this;
		Promise.createContext = function(p, context) {
			p.context = self.createContext(p, context);
		};

		Promise.enterContext = function(p) {
			executionContext.push(p.context);
		};

		Promise.exitContext = function() {
			executionContext.pop();
		};

		Promise.onPotentiallyUnhandledRejection = function(rejection, extraContext) {
			return self.addTrace(rejection, extraContext);
		};

		Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
			return self.removeTrace(rejection);
		};

		Promise.onFatalRejection = function(rejection, extraContext) {
			return self.fatal(rejection, extraContext);
		};

		return this;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	var PromiseMonitor = require('./monitor/PromiseMonitor');
	var ConsoleReporter = require('./monitor/ConsoleReporter');

	var promiseMonitor = new PromiseMonitor(new ConsoleReporter());

	return function(Promise) {
		return promiseMonitor.<span class="apidocCodeKeywordSpan">monitor</span>(Promise);
	};
});
}(typeof define === 'function' &amp;&amp; define.amd ? define : function(factory) { module.exports = factory(require
); }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.PromiseMonitor.prototype.removeTrace" id="apidoc.element.when.PromiseMonitor.prototype.removeTrace">
        function <span class="apidocSignatureSpan">when.PromiseMonitor.prototype.</span>removeTrace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTrace = function () {
		this.logTraces();
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		};

		Promise.onPotentiallyUnhandledRejection = function(rejection, extraContext) {
			return self.addTrace(rejection, extraContext);
		};

		Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
			return self.<span class="apidocCodeKeywordSpan">removeTrace</span>(rejection);
		};

		Promise.onFatalRejection = function(rejection, extraContext) {
			return self.fatal(rejection, extraContext);
		};

		return this;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.Scheduler" id="apidoc.module.when.Scheduler">module when.Scheduler</a></h1>


    <h2>
        <a href="#apidoc.element.when.Scheduler.Scheduler" id="apidoc.element.when.Scheduler.Scheduler">
        function <span class="apidocSignatureSpan">when.</span>Scheduler
        <span class="apidocSignatureSpan">(async)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Scheduler(async) {
		this._async = async;
		this._running = false;

		this._queue = this;
		this._queueLen = 0;
		this._afterQueue = {};
		this._afterQueueLen = 0;

		var self = this;
		this.drain = function() {
			self._drain();
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.Scheduler.prototype" id="apidoc.module.when.Scheduler.prototype">module when.Scheduler.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.when.Scheduler.prototype._drain" id="apidoc.element.when.Scheduler.prototype._drain">
        function <span class="apidocSignatureSpan">when.Scheduler.prototype.</span>_drain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_drain = function () {
		var i = 0;
		for (; i &lt; this._queueLen; ++i) {
			this._queue[i].run();
			this._queue[i] = void 0;
		}

		this._queueLen = 0;
		this._running = false;

		for (i = 0; i &lt; this._afterQueueLen; ++i) {
			this._afterQueue[i].run();
			this._afterQueue[i] = void 0;
		}

		this._afterQueueLen = 0;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		this._queue = this;
		this._queueLen = 0;
		this._afterQueue = {};
		this._afterQueueLen = 0;

		var self = this;
		this.drain = function() {
			self.<span class="apidocCodeKeywordSpan">_drain</span>();
		};
	}

	/**
	 * Enqueue a task
	 * @param {{ run:function }} task
	 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Scheduler.prototype.afterQueue" id="apidoc.element.when.Scheduler.prototype.afterQueue">
        function <span class="apidocSignatureSpan">when.Scheduler.prototype.</span>afterQueue
        <span class="apidocSignatureSpan">(task)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterQueue = function (task) {
		this._afterQueue[this._afterQueueLen++] = task;
		this.run();
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			if(typeof cont.rejected === 'function') {
				this._unreport();
			}
			runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);
		};

		Rejected.prototype._report = function(context) {
			tasks.<span class="apidocCodeKeywordSpan">afterQueue</span>(new ReportTask(this, context));
		};

		Rejected.prototype._unreport = function() {
			if(this.handled) {
				return;
			}
			this.handled = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Scheduler.prototype.enqueue" id="apidoc.element.when.Scheduler.prototype.enqueue">
        function <span class="apidocSignatureSpan">when.Scheduler.prototype.</span>enqueue
        <span class="apidocSignatureSpan">(task)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enqueue = function (task) {
		this._queue[this._queueLen++] = task;
		this.run();
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			if(this.resolved) {
				return;
			}

			this.resolved = true;
			this.handler = handler;
			if(this.consumers !== void 0) {
				tasks.<span class="apidocCodeKeywordSpan">enqueue</span>(this);
			}

			if(this.context !== void 0) {
				handler._report(this.context);
			}
		};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.Scheduler.prototype.run" id="apidoc.element.when.Scheduler.prototype.run">
        function <span class="apidocSignatureSpan">when.Scheduler.prototype.</span>run
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function () {
		if (!this._running) {
			this._running = true;
			this._async(this.drain);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	/**
	 * Enqueue a task
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.enqueue = function(task) {
		this._queue[this._queueLen++] = task;
		this.<span class="apidocCodeKeywordSpan">run</span>();
	};

	/**
	 * Enqueue a task to run after the main task queue
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.afterQueue = function(task) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.TimeoutError" id="apidoc.module.when.TimeoutError">module when.TimeoutError</a></h1>


    <h2>
        <a href="#apidoc.element.when.TimeoutError.TimeoutError" id="apidoc.element.when.TimeoutError.TimeoutError">
        function <span class="apidocSignatureSpan">when.</span>TimeoutError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimeoutError(message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === 'function') {
			Error.captureStackTrace(this, TimeoutError);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.TimeoutError.prototype" id="apidoc.module.when.TimeoutError.prototype">module when.TimeoutError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.when.TimeoutError.prototype.constructor" id="apidoc.element.when.TimeoutError.prototype.constructor">
        function <span class="apidocSignatureSpan">when.TimeoutError.prototype.</span>constructor
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimeoutError(message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === 'function') {
			Error.captureStackTrace(this, TimeoutError);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		Promise.prototype.then = function(onFulfilled, onRejected, onProgress) {
			var parent = this._handler;
			var state = parent.join().state();

			if ((typeof onFulfilled !== 'function' &amp;&amp; state &gt; 0) ||
				(typeof onRejected !== 'function' &amp;&amp; state &lt; 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.<span class="apidocCodeKeywordSpan">constructor</span>(Handler, parent);
			}

			var p = this._beget();
			var child = p._handler;

			parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.apply" id="apidoc.module.when.apply">module when.apply</a></h1>


    <h2>
        <a href="#apidoc.element.when.apply.apply" id="apidoc.element.when.apply.apply">
        function <span class="apidocSignatureSpan">when.</span>apply
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function apply() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 * Takes a `traditional` callback-taking function and returns a promise for its
	 * result, accepting an optional array of arguments (that might be values or
	 * promises). It assumes that the function takes its callback and errback as
	 * the last two arguments. The resolution of the promise depends on whether the
	 * function will call its callback or its errback.
	 *
	 * @example
	 *    var domIsLoaded = callbacks.<span class="apidocCodeKeywordSpan">apply</span>($);
	 *    domIsLoaded.then(function() {
	 *		doMyDomStuff();
	 *	});
	 *
	 * @example
	 *    function existingAjaxyFunction(url, callback, errback) {
	 *		// Complex logic you'd rather not change
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.apply.tryCatchResolve" id="apidoc.element.when.apply.tryCatchResolve">
        function <span class="apidocSignatureSpan">when.apply.</span>tryCatchResolve
        <span class="apidocSignatureSpan">(f, thisArg, args, resolver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryCatchResolve(f, thisArg, args, resolver) {
		try {
			resolver.resolve(f.apply(thisArg, args));
		} catch(e) {
			resolver.reject(e);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.callbacks" id="apidoc.module.when.callbacks">module when.callbacks</a></h1>


    <h2>
        <a href="#apidoc.element.when.callbacks.apply" id="apidoc.element.when.callbacks.apply">
        function <span class="apidocSignatureSpan">when.callbacks.</span>apply
        <span class="apidocSignatureSpan">(asyncFunction, extraAsyncArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function apply(asyncFunction, extraAsyncArgs) {
		return _apply(asyncFunction, this, extraAsyncArgs || []);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 * Takes a `traditional` callback-taking function and returns a promise for its
	 * result, accepting an optional array of arguments (that might be values or
	 * promises). It assumes that the function takes its callback and errback as
	 * the last two arguments. The resolution of the promise depends on whether the
	 * function will call its callback or its errback.
	 *
	 * @example
	 *    var domIsLoaded = callbacks.<span class="apidocCodeKeywordSpan">apply</span>($);
	 *    domIsLoaded.then(function() {
	 *		doMyDomStuff();
	 *	});
	 *
	 * @example
	 *    function existingAjaxyFunction(url, callback, errback) {
	 *		// Complex logic you'd rather not change
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.callbacks.call" id="apidoc.element.when.callbacks.call">
        function <span class="apidocSignatureSpan">when.callbacks.</span>call
        <span class="apidocSignatureSpan">(asyncFunction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function call(asyncFunction) {
		return _apply(asyncFunction, this, slice.call(arguments, 1));
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 * @example
	 *    function sumInFiveSeconds(a, b, callback) {
	 *		setTimeout(function() {
	 *			callback(a + b);
	 *		}, 5000);
	 *	}
	 *
	 *    var sumPromise = callbacks.<span class="apidocCodeKeywordSpan">call</span>(sumInFiveSeconds, 5, 10);
	 *
	 *    // Logs '15' 5 seconds later
	 *    sumPromise.then(console.log);
	 *
	 * @param {function} asyncFunction function to be called
	 * @param {...*} args arguments that will be forwarded to the function
	 * @returns {Promise} promise for the callback value of asyncFunction
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.callbacks.lift" id="apidoc.element.when.callbacks.lift">
        function <span class="apidocSignatureSpan">when.callbacks.</span>lift
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lift(f) {
		var args = arguments.length &gt; 1 ? slice.call(arguments, 1) : [];
		return function() {
			return _apply(f, this, args.concat(slice.call(arguments)));
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 *
	 *		xhr.onload = callback;
	 *		xhr.onerror = errback;
	 *
	 *		xhr.send();
	 *	}
	 *
	 *    var promiseAjax = callbacks.<span class="apidocCodeKeywordSpan">lift</span>(traditionalAjax);
	 *    promiseAjax("GET", "/movies.json").then(console.log, console.error);
	 *
	 *    var promiseAjaxGet = callbacks.lift(traditionalAjax, "GET");
	 *    promiseAjaxGet("/movies.json").then(console.log, console.error);
	 *
	 * @param {Function} f traditional async function to be decorated
	 * @param {...*} [args] arguments to be prepended for the new function @deprecated
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.callbacks.liftAll" id="apidoc.element.when.callbacks.liftAll">
        function <span class="apidocSignatureSpan">when.callbacks.</span>liftAll
        <span class="apidocSignatureSpan">(src, combine, dst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function liftAll(src, combine, dst) {
		return _liftAll(lift, combine, dst, src);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### 3.0.0

* New internal architecture with significant performance improvements and memory efficiency
* New APIs
	* [`when.try`](docs/api.md#whentry), [`when.lift`](docs/api.md#whenlift), [`when.reduceRight`](docs/api.md#whenreduceRight), [`
when.iterate`](docs/api.md#wheniterate), [`when.unfold`](docs/api.md#whenunfold), [`when.race`](docs/api.md#whenrace)
	* [`promise.with`](docs/api.md#promisewith), [`promise.else`](docs/api.md#promiseelse), [`promise.delay`](docs/api.md#promisedelay
), [`promise.timeout`](docs/api.md#promisetimeout), [`promise.progress`](docs/api.md#promiseprogress)
* New liftAll variants for lifting all of an object's functions in one shot, eg. `var promisedFs = node.<span class="apidocCodeKeywordSpan
">liftAll</span>(require('fs'))`
	* [`fn.liftAll`](docs/api.md#fnliftall), [`node.liftAll`](docs/api.md#nodeliftall), [`callbacks.liftAll`](docs/api.md#callbacksliftall
)
* `when.Promise` public, inheritance-friendly, Promise constructor
* New [ES6 Promise shim](docs/es6-promise-shim.md)
* Check out the [tips for upgrading to 3.0 from 2.x](docs/api.md#upgrading-to-30-from-2x)

### 2.8.0
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.callbacks.promisify" id="apidoc.element.when.callbacks.promisify">
        function <span class="apidocSignatureSpan">when.callbacks.</span>promisify
        <span class="apidocSignatureSpan">(asyncFunction, positions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisify(asyncFunction, positions) {

		return function() {
			var thisArg = this;
			return Promise.all(arguments).then(function(args) {
				var p = Promise._defer();

				var callbackPos, errbackPos;

				if(typeof positions.callback === 'number') {
					callbackPos = normalizePosition(args, positions.callback);
				}

				if(typeof positions.errback === 'number') {
					errbackPos = normalizePosition(args, positions.errback);
				}

				if(errbackPos &lt; callbackPos) {
					insertCallback(args, errbackPos, p._handler.reject, p._handler);
					insertCallback(args, callbackPos, p._handler.resolve, p._handler);
				} else {
					insertCallback(args, callbackPos, p._handler.resolve, p._handler);
					insertCallback(args, errbackPos, p._handler.reject, p._handler);
				}

				asyncFunction.apply(thisArg, args);

				return p;
			});
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 * of the arguments array.
	 *
	 * If arguments are given on the call to the 'promisified' function, they are
	 * intermingled with the callback and errback. If a promise is given among them,
	 * the execution of the function will only occur after its resolution.
	 *
	 * @example
	 *    var delay = callbacks.<span class="apidocCodeKeywordSpan">promisify</span>(setTimeout, {
	 *		callback: 0
	 *	});
	 *
	 *    delay(100).then(function() {
	 *		console.log("This happens 100ms afterwards");
	 *	});
	 *
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.console" id="apidoc.module.when.console">module when.console</a></h1>




    <h2>
        <a href="#apidoc.element.when.console._doLogTraces" id="apidoc.element.when.console._doLogTraces">
        function <span class="apidocSignatureSpan">when.console.</span>_doLogTraces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doLogTraces = function () {
			self._logTraces();
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.env" id="apidoc.module.when.env">module when.env</a></h1>


    <h2>
        <a href="#apidoc.element.when.env.asap" id="apidoc.element.when.env.asap">
        function <span class="apidocSignatureSpan">when.env.</span>asap
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asap = function (f) { return process.nextTick(f); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.env.clearTimer" id="apidoc.element.when.env.clearTimer">
        function <span class="apidocSignatureSpan">when.env.</span>clearTimer
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearTimer = function (t) { return clearTimeout(t); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			var p = this._beget();
			var h = p._handler;

			var t = setTimeout(onTimeout, ms, reason, p._handler);

			this._handler.visit(h,
				function onFulfill(x) {
					env.<span class="apidocCodeKeywordSpan">clearTimer</span>(t);
					this.resolve(x); // this = h
				},
				function onReject(x) {
					env.clearTimer(t);
					this.reject(x); // this = h
				},
				h.notify);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.env.setTimer" id="apidoc.element.when.env.setTimer">
        function <span class="apidocSignatureSpan">when.env.</span>setTimer
        <span class="apidocSignatureSpan">(f, ms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTimer = function (f, ms) { return setTimeout(f, ms); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	} else if (MutationObs = hasMutationObserver()) { // Modern browser
		asap = initMutationObserver(MutationObs);

	} else if (!capturedSetTimeout) { // vert.x
		var vertxRequire = require;
		var vertx = vertxRequire('vertx');
		setTimer = function (f, ms) { return vertx.<span class="apidocCodeKeywordSpan">setTimer</span>(ms, f); };
		clearTimer = vertx.cancelTimer;
		asap = vertx.runOnLoop || vertx.runOnContext;
	}

	return {
		setTimer: setTimer,
		clearTimer: clearTimer,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.error" id="apidoc.module.when.error">module when.error</a></h1>


    <h2>
        <a href="#apidoc.element.when.error.captureStack" id="apidoc.element.when.error.captureStack">
        function <span class="apidocSignatureSpan">when.error.</span>captureStack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function captureStackTrace() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	};

	PromiseMonitor.prototype.createContext = function(at, parentContext) {
		var context = {
			parent: parentContext || executionContext[executionContext.length - 1],
			stack: void 0
		};
		error.<span class="apidocCodeKeywordSpan">captureStack</span>(context, at.constructor);
		return context;
	};

	PromiseMonitor.prototype.addTrace = function(handler, extraContext) {
		var t, i;

		for(i = this._traces.length-1; i &gt;= 0; --i) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.error.format" id="apidoc.element.when.error.format">
        function <span class="apidocSignatureSpan">when.error.</span>format
        <span class="apidocSignatureSpan">(longTrace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatAsString(longTrace) {
		return join(longTrace);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		} finally {
			this.groupEnd();
		}
	};

	ConsoleReporter.prototype._log = function(traces) {
		for(var i=0; i&lt;traces.length; ++i) {
			this.warn(error.<span class="apidocCodeKeywordSpan">format</span>(traces[i]));
		}
	};

	function initDefaultLogging() {
		/*jshint maxcomplexity:7*/
		var log, warn, groupStart, groupEnd;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.error.parse" id="apidoc.element.when.error.parse">
        function <span class="apidocSignatureSpan">when.error.</span>parse
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (e) {
			return e &amp;&amp; e.stack &amp;&amp; e.stack.split('\n');
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	PromiseMonitor.prototype.formatTraces = function(traces) {
		return traces.map(function(t) {
			return this._createLongTrace(t.handler.value, t.handler.context, t.extraContext);
		}, this);
	};

	PromiseMonitor.prototype._createLongTrace = function(e, context, extraContext) {
		var trace = error.<span class="apidocCodeKeywordSpan">parse</span>(e) || [String(e) + ' (WARNING: non-Error used)'];
		trace = filterFrames(this.stackFilter, trace, 0);
		this._appendContext(trace, context);
		this._appendContext(trace, extraContext);
		return this.filterDuplicateFrames ? this._removeDuplicates(trace) : trace;
	};

	PromiseMonitor.prototype._removeDuplicates = function(trace) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.format" id="apidoc.module.when.format">module when.format</a></h1>


    <h2>
        <a href="#apidoc.element.when.format.formatError" id="apidoc.element.when.format.formatError">
        function <span class="apidocSignatureSpan">when.format.</span>formatError
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatError(e) {
		var s = typeof e === 'object' &amp;&amp; e !== null &amp;&amp; (e.stack || e.message) ? e.stack || e.message : formatObject(e);
		return e instanceof Error ? s : s + ' (WARNING: non-Error used)';
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		var tasks = [];
		var reported = [];
		var running = null;

		function report(r) {
			if(!r.handled) {
				reported.push(r);
				logError('Potentially unhandled rejection [' + r.id + '] ' + format.<span class="apidocCodeKeywordSpan">
formatError</span>(r.value));
			}
		}

		function unreport(r) {
			var i = reported.indexOf(r);
			if(i &gt;= 0) {
				reported.splice(i, 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.format.formatObject" id="apidoc.element.when.format.formatObject">
        function <span class="apidocSignatureSpan">when.format.</span>formatObject
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatObject(o) {
		var s = String(o);
		if(s === '[object Object]' &amp;&amp; typeof JSON !== 'undefined') {
			s = tryStringify(o, s);
		}
		return s;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}
		}

		function unreport(r) {
			var i = reported.indexOf(r);
			if(i &gt;= 0) {
				reported.splice(i, 1);
				logInfo('Handled previous rejection [' + r.id + '] ' + format.<span class="apidocCodeKeywordSpan">formatObject
</span>(r.value));
			}
		}

		function enqueue(f, x) {
			tasks.push(f, x);
			if(running === null) {
				running = setTimer(flush, 0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.format.tryStringify" id="apidoc.element.when.format.tryStringify">
        function <span class="apidocSignatureSpan">when.format.</span>tryStringify
        <span class="apidocSignatureSpan">(x, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryStringify(x, defaultValue) {
		try {
			return JSON.stringify(x);
		} catch(e) {
			return defaultValue;
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.function" id="apidoc.module.when.function">module when.function</a></h1>


    <h2>
        <a href="#apidoc.element.when.function.apply" id="apidoc.element.when.function.apply">
        function <span class="apidocSignatureSpan">when.function.</span>apply
        <span class="apidocSignatureSpan">(f, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function apply(f, args) {
		// slice args just in case the caller passed an Arguments instance
		return _apply(f, this, args == null ? [] : slice.call(args));
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 * Takes a `traditional` callback-taking function and returns a promise for its
	 * result, accepting an optional array of arguments (that might be values or
	 * promises). It assumes that the function takes its callback and errback as
	 * the last two arguments. The resolution of the promise depends on whether the
	 * function will call its callback or its errback.
	 *
	 * @example
	 *    var domIsLoaded = callbacks.<span class="apidocCodeKeywordSpan">apply</span>($);
	 *    domIsLoaded.then(function() {
	 *		doMyDomStuff();
	 *	});
	 *
	 * @example
	 *    function existingAjaxyFunction(url, callback, errback) {
	 *		// Complex logic you'd rather not change
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.function.call" id="apidoc.element.when.function.call">
        function <span class="apidocSignatureSpan">when.function.</span>call
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function attempt(f) {
		<span class="apidocCodeCommentSpan">/*jshint validthis:true */
</span>		for(var i=0, l=arguments.length-1, a=new Array(l); i&lt;l; ++i) {
			a[i] = arguments[i+1];
		}
		return apply(f, this, a);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 * @example
	 *    function sumInFiveSeconds(a, b, callback) {
	 *		setTimeout(function() {
	 *			callback(a + b);
	 *		}, 5000);
	 *	}
	 *
	 *    var sumPromise = callbacks.<span class="apidocCodeKeywordSpan">call</span>(sumInFiveSeconds, 5, 10);
	 *
	 *    // Logs '15' 5 seconds later
	 *    sumPromise.then(console.log);
	 *
	 * @param {function} asyncFunction function to be called
	 * @param {...*} args arguments that will be forwarded to the function
	 * @returns {Promise} promise for the callback value of asyncFunction
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.function.compose" id="apidoc.element.when.function.compose">
        function <span class="apidocSignatureSpan">when.function.</span>compose
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compose(f) {
		var funcs = slice.call(arguments, 1);

		return function() {
			var thisArg = this;
			var args = slice.call(arguments);
			var firstPromise = attempt.apply(thisArg, [f].concat(args));

			return when.reduce(funcs, function(arg, func) {
				return func.call(thisArg, arg);
			}, firstPromise);
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.function.lift" id="apidoc.element.when.function.lift">
        function <span class="apidocSignatureSpan">when.function.</span>lift
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lift(f) {
		var args = arguments.length &gt; 1 ? slice.call(arguments, 1) : [];
		return function() {
			return _apply(f, this, args.concat(slice.call(arguments)));
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 *
	 *		xhr.onload = callback;
	 *		xhr.onerror = errback;
	 *
	 *		xhr.send();
	 *	}
	 *
	 *    var promiseAjax = callbacks.<span class="apidocCodeKeywordSpan">lift</span>(traditionalAjax);
	 *    promiseAjax("GET", "/movies.json").then(console.log, console.error);
	 *
	 *    var promiseAjaxGet = callbacks.lift(traditionalAjax, "GET");
	 *    promiseAjaxGet("/movies.json").then(console.log, console.error);
	 *
	 * @param {Function} f traditional async function to be decorated
	 * @param {...*} [args] arguments to be prepended for the new function @deprecated
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.function.liftAll" id="apidoc.element.when.function.liftAll">
        function <span class="apidocSignatureSpan">when.function.</span>liftAll
        <span class="apidocSignatureSpan">(src, combine, dst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function liftAll(src, combine, dst) {
		return _liftAll(lift, combine, dst, src);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### 3.0.0

* New internal architecture with significant performance improvements and memory efficiency
* New APIs
	* [`when.try`](docs/api.md#whentry), [`when.lift`](docs/api.md#whenlift), [`when.reduceRight`](docs/api.md#whenreduceRight), [`
when.iterate`](docs/api.md#wheniterate), [`when.unfold`](docs/api.md#whenunfold), [`when.race`](docs/api.md#whenrace)
	* [`promise.with`](docs/api.md#promisewith), [`promise.else`](docs/api.md#promiseelse), [`promise.delay`](docs/api.md#promisedelay
), [`promise.timeout`](docs/api.md#promisetimeout), [`promise.progress`](docs/api.md#promiseprogress)
* New liftAll variants for lifting all of an object's functions in one shot, eg. `var promisedFs = node.<span class="apidocCodeKeywordSpan
">liftAll</span>(require('fs'))`
	* [`fn.liftAll`](docs/api.md#fnliftall), [`node.liftAll`](docs/api.md#nodeliftall), [`callbacks.liftAll`](docs/api.md#callbacksliftall
)
* `when.Promise` public, inheritance-friendly, Promise constructor
* New [ES6 Promise shim](docs/es6-promise-shim.md)
* Check out the [tips for upgrading to 3.0 from 2.x](docs/api.md#upgrading-to-30-from-2x)

### 2.8.0
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.generator" id="apidoc.module.when.generator">module when.generator</a></h1>


    <h2>
        <a href="#apidoc.element.when.generator.apply" id="apidoc.element.when.generator.apply">
        function <span class="apidocSignatureSpan">when.generator.</span>apply
        <span class="apidocSignatureSpan">(generator, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function apply(generator, args) {
		<span class="apidocCodeCommentSpan">/*jshint validthis:true*/
</span>		return run(generator, this, args || []);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 * Takes a `traditional` callback-taking function and returns a promise for its
	 * result, accepting an optional array of arguments (that might be values or
	 * promises). It assumes that the function takes its callback and errback as
	 * the last two arguments. The resolution of the promise depends on whether the
	 * function will call its callback or its errback.
	 *
	 * @example
	 *    var domIsLoaded = callbacks.<span class="apidocCodeKeywordSpan">apply</span>($);
	 *    domIsLoaded.then(function() {
	 *		doMyDomStuff();
	 *	});
	 *
	 * @example
	 *    function existingAjaxyFunction(url, callback, errback) {
	 *		// Complex logic you'd rather not change
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.generator.call" id="apidoc.element.when.generator.call">
        function <span class="apidocSignatureSpan">when.generator.</span>call
        <span class="apidocSignatureSpan">(generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function call(generator) {
		<span class="apidocCodeCommentSpan">/*jshint validthis:true*/
</span>		return run(generator, this, slice.call(arguments, 1));
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 * @example
	 *    function sumInFiveSeconds(a, b, callback) {
	 *		setTimeout(function() {
	 *			callback(a + b);
	 *		}, 5000);
	 *	}
	 *
	 *    var sumPromise = callbacks.<span class="apidocCodeKeywordSpan">call</span>(sumInFiveSeconds, 5, 10);
	 *
	 *    // Logs '15' 5 seconds later
	 *    sumPromise.then(console.log);
	 *
	 * @param {function} asyncFunction function to be called
	 * @param {...*} args arguments that will be forwarded to the function
	 * @returns {Promise} promise for the callback value of asyncFunction
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.generator.lift" id="apidoc.element.when.generator.lift">
        function <span class="apidocSignatureSpan">when.generator.</span>lift
        <span class="apidocSignatureSpan">(generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lift(generator) {
		return function() {
			return run(generator, this, arguments);
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 *
	 *		xhr.onload = callback;
	 *		xhr.onerror = errback;
	 *
	 *		xhr.send();
	 *	}
	 *
	 *    var promiseAjax = callbacks.<span class="apidocCodeKeywordSpan">lift</span>(traditionalAjax);
	 *    promiseAjax("GET", "/movies.json").then(console.log, console.error);
	 *
	 *    var promiseAjaxGet = callbacks.lift(traditionalAjax, "GET");
	 *    promiseAjaxGet("/movies.json").then(console.log, console.error);
	 *
	 * @param {Function} f traditional async function to be decorated
	 * @param {...*} [args] arguments to be prepended for the new function @deprecated
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.guard" id="apidoc.module.when.guard">module when.guard</a></h1>


    <h2>
        <a href="#apidoc.element.when.guard.guard" id="apidoc.element.when.guard.guard">
        function <span class="apidocSignatureSpan">when.</span>guard
        <span class="apidocSignatureSpan">(condition, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function guard(condition, f) {
		return function() {
			var args = slice.call(arguments);

			return when(condition()).withThis(this).then(function(exit) {
				return when(f.apply(this, args))['finally'](exit);
			});
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.guard.n" id="apidoc.element.when.guard.n">
        function <span class="apidocSignatureSpan">when.guard.</span>n
        <span class="apidocSignatureSpan">(allowed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function n(allowed) {
		var count = 0;
		var waiting = [];

		return function enter() {
			return when.promise(function(resolve) {
				if(count &lt; allowed) {
					resolve(exit);
				} else {
					waiting.push(resolve);
				}
				count += 1;
			});
		};

		function exit() {
			count = Math.max(count - 1, 0);
			if(waiting.length &gt; 0) {
				waiting.shift()(exit);
			}
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.keys" id="apidoc.module.when.keys">module when.keys</a></h1>


    <h2>
        <a href="#apidoc.element.when.keys.all" id="apidoc.element.when.keys.all">
        function <span class="apidocSignatureSpan">when.keys.</span>all
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">all = function () {
			for(var i=0, l=arguments.length, a=new Array(l); i&lt;l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 *
	 * @deprecated
	 */
	function promisify(asyncFunction, positions) {

		return function() {
			var thisArg = this;
			return Promise.<span class="apidocCodeKeywordSpan">all</span>(arguments).then(function(args) {
				var p = Promise._defer();

				var callbackPos, errbackPos;

				if(typeof positions.callback === 'number') {
					callbackPos = normalizePosition(args, positions.callback);
				}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.keys.map" id="apidoc.element.when.keys.map">
        function <span class="apidocSignatureSpan">when.keys.</span>map
        <span class="apidocSignatureSpan">(object, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(object, f) {
		return toPromise(object).then(function(object) {
			return all(Object.keys(object).reduce(function(o, k) {
				o[k] = toPromise(object[k]).fold(mapWithKey, k);
				return o;
			}, {}));
		});

		function mapWithKey(k, x) {
			return f(x, k);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* Updated [wiki](https://github.com/cujojs/when/wiki) map/reduce examples, and added simple promise forwarding example
* Fix for calling `when.any()` without a callback ([#33](https://github.com/cujojs/when/issues/33))
* Fix version number in `when.js` source ([#36](https://github.com/cujojs/when/issues/36))

### 1.1.0

* `when.all/any/some/map/reduce` can all now accept a promise for an array in addition to an actual array as input.  This allows
 composing functions to do interesting things like `when.reduce(when.<span class="apidocCodeKeywordSpan">map</span>(...))`
* `when.reject(promiseOrValue)` that returns a new, rejected promise.
* `promise.always(callback)` as a shortcut for `promise.then(callback, callback)`
* **Highly experimental** [when/debug](https://github.com/cujojs/when/wiki/when-debug) module: a drop-in replacement for the main
 `when` module that enables debug logging for promises created or consumed by when.js

### 1.0.4

* [Travis CI](http://travis-ci.org/cujojs/when) integration
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.keys.settle" id="apidoc.element.when.keys.settle">
        function <span class="apidocSignatureSpan">when.keys.</span>settle
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function settle(object) {
		var keys = Object.keys(object);
		var results = {};

		if(keys.length === 0) {
			return toPromise(results);
		}

		var p = Promise._defer();
		var resolver = Promise._handler(p);
		var promises = keys.map(function(k) { return object[k]; });

		when.settle(promises).then(function(states) {
			populateResults(keys, states, results, resolver);
		});

		return p;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			return toPromise(results);
		}

		var p = Promise._defer();
		var resolver = Promise._handler(p);
		var promises = keys.map(function(k) { return object[k]; });

		when.<span class="apidocCodeKeywordSpan">settle</span>(promises).then(function(states) {
			populateResults(keys, states, results, resolver);
		});

		return p;
	}

	function populateResults(keys, states, results, resolver) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.node" id="apidoc.module.when.node">module when.node</a></h1>


    <h2>
        <a href="#apidoc.element.when.node.apply" id="apidoc.element.when.node.apply">
        function <span class="apidocSignatureSpan">when.node.</span>apply
        <span class="apidocSignatureSpan">(f, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function apply(f, args) {
		return _apply(f, this, args || []);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 * Takes a `traditional` callback-taking function and returns a promise for its
	 * result, accepting an optional array of arguments (that might be values or
	 * promises). It assumes that the function takes its callback and errback as
	 * the last two arguments. The resolution of the promise depends on whether the
	 * function will call its callback or its errback.
	 *
	 * @example
	 *    var domIsLoaded = callbacks.<span class="apidocCodeKeywordSpan">apply</span>($);
	 *    domIsLoaded.then(function() {
	 *		doMyDomStuff();
	 *	});
	 *
	 * @example
	 *    function existingAjaxyFunction(url, callback, errback) {
	 *		// Complex logic you'd rather not change
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.node.bindCallback" id="apidoc.element.when.node.bindCallback">
        function <span class="apidocSignatureSpan">when.node.</span>bindCallback
        <span class="apidocSignatureSpan">(promise, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bindCallback(promise, callback) {
		promise = when(promise);

		if (callback) {
			promise.then(success, wrapped);
		}

		return promise;

		function success(value) {
			wrapped(null, value);
		}

		function wrapped(err, value) {
			setTimer(function () {
				callback(err, value);
			}, 0);
		}
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.node.call" id="apidoc.element.when.node.call">
        function <span class="apidocSignatureSpan">when.node.</span>call
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function call(f) {
		return _apply(f, this, slice.call(arguments, 1));
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 * @example
	 *    function sumInFiveSeconds(a, b, callback) {
	 *		setTimeout(function() {
	 *			callback(a + b);
	 *		}, 5000);
	 *	}
	 *
	 *    var sumPromise = callbacks.<span class="apidocCodeKeywordSpan">call</span>(sumInFiveSeconds, 5, 10);
	 *
	 *    // Logs '15' 5 seconds later
	 *    sumPromise.then(console.log);
	 *
	 * @param {function} asyncFunction function to be called
	 * @param {...*} args arguments that will be forwarded to the function
	 * @returns {Promise} promise for the callback value of asyncFunction
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.node.createCallback" id="apidoc.element.when.node.createCallback">
        function <span class="apidocSignatureSpan">when.node.</span>createCallback
        <span class="apidocSignatureSpan">(resolver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCallback(resolver) {
		return function(err, value) {
			if(err) {
				resolver.reject(err);
			} else if(arguments.length &gt; 2) {
				resolver.resolve(slice.call(arguments, 1));
			} else {
				resolver.resolve(value);
			}
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 *			callback(null, interestingValue);
	 *		}
	 *	}
	 *
	 *	var when = require('when'), nodefn = require('when/node/function');
	 *
	 *	var deferred = when.defer();
	 *	callbackTakingFunction(nodefn.<span class="apidocCodeKeywordSpan">createCallback</span>(deferred.resolver));
	 *
	 *	deferred.promise.then(function(interestingValue) {
	 *		// Use interestingValue
	 *	});
	 *
	 * @param {Resolver} resolver that will be 'attached' to the callback
	 * @returns {Function} a node-style callback function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.node.lift" id="apidoc.element.when.node.lift">
        function <span class="apidocSignatureSpan">when.node.</span>lift
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lift(f) {
		var args1 = arguments.length &gt; 1 ? slice.call(arguments, 1) : [];
		return function() {
			// TODO: Simplify once partialing has been removed
			var l = args1.length;
			var al = arguments.length;
			var args = new Array(al + l);
			var i;
			for(i=0; i&lt;l; ++i) {
				args[i] = args1[i];
			}
			for(i=0; i&lt;al; ++i) {
				args[i+l] = arguments[i];
			}
			return _apply(f, this, args);
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	 *
	 *		xhr.onload = callback;
	 *		xhr.onerror = errback;
	 *
	 *		xhr.send();
	 *	}
	 *
	 *    var promiseAjax = callbacks.<span class="apidocCodeKeywordSpan">lift</span>(traditionalAjax);
	 *    promiseAjax("GET", "/movies.json").then(console.log, console.error);
	 *
	 *    var promiseAjaxGet = callbacks.lift(traditionalAjax, "GET");
	 *    promiseAjaxGet("/movies.json").then(console.log, console.error);
	 *
	 * @param {Function} f traditional async function to be decorated
	 * @param {...*} [args] arguments to be prepended for the new function @deprecated
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.node.liftAll" id="apidoc.element.when.node.liftAll">
        function <span class="apidocSignatureSpan">when.node.</span>liftAll
        <span class="apidocSignatureSpan">(src, combine, dst)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function liftAll(src, combine, dst) {
		return _liftAll(lift, combine, dst, src);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### 3.0.0

* New internal architecture with significant performance improvements and memory efficiency
* New APIs
	* [`when.try`](docs/api.md#whentry), [`when.lift`](docs/api.md#whenlift), [`when.reduceRight`](docs/api.md#whenreduceRight), [`
when.iterate`](docs/api.md#wheniterate), [`when.unfold`](docs/api.md#whenunfold), [`when.race`](docs/api.md#whenrace)
	* [`promise.with`](docs/api.md#promisewith), [`promise.else`](docs/api.md#promiseelse), [`promise.delay`](docs/api.md#promisedelay
), [`promise.timeout`](docs/api.md#promisetimeout), [`promise.progress`](docs/api.md#promiseprogress)
* New liftAll variants for lifting all of an object's functions in one shot, eg. `var promisedFs = node.<span class="apidocCodeKeywordSpan
">liftAll</span>(require('fs'))`
	* [`fn.liftAll`](docs/api.md#fnliftall), [`node.liftAll`](docs/api.md#nodeliftall), [`callbacks.liftAll`](docs/api.md#callbacksliftall
)
* `when.Promise` public, inheritance-friendly, Promise constructor
* New [ES6 Promise shim](docs/es6-promise-shim.md)
* Check out the [tips for upgrading to 3.0 from 2.x](docs/api.md#upgrading-to-30-from-2x)

### 2.8.0
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.node.liftCallback" id="apidoc.element.when.node.liftCallback">
        function <span class="apidocSignatureSpan">when.node.</span>liftCallback
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function liftCallback(callback) {
		return function(promise) {
			return bindCallback(promise, callback);
		};
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.when.state" id="apidoc.module.when.state">module when.state</a></h1>


    <h2>
        <a href="#apidoc.element.when.state.fulfilled" id="apidoc.element.when.state.fulfilled">
        function <span class="apidocSignatureSpan">when.state.</span>fulfilled
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toFulfilledState(x) {
		return { state: 'fulfilled', value: x };
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.state.inspect" id="apidoc.element.when.state.inspect">
        function <span class="apidocSignatureSpan">when.state.</span>inspect
        <span class="apidocSignatureSpan">(handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inspect(handler) {
		var state = handler.state();
		return state === 0 ? toPendingState()
			 : state &gt; 0   ? toFulfilledState(handler.value)
			               : toRejectedState(handler.value);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				return toPromise(p).then(state.fulfilled, state.rejected);
			}

			// The promise is our own, but it is already resolved. Take a shortcut.
			// Since we're not actually handling the resolution, we need to disable
			// rejection reporting.
			handler._unreport();
			return state.<span class="apidocCodeKeywordSpan">inspect</span>(handler);
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.state.pending" id="apidoc.element.when.state.pending">
        function <span class="apidocSignatureSpan">when.state.</span>pending
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toPendingState() {
		return { state: 'pending' };
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.when.state.rejected" id="apidoc.element.when.state.rejected">
        function <span class="apidocSignatureSpan">when.state.</span>rejected
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toRejectedState(e) {
		return { state: 'rejected', reason: e };
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>